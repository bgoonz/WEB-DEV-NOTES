{
  "template": {
    "taskId": "fa0b52f6-b2a5-4324-8a8d-be368da5696b",
    "name": "Validations With Sequelize",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/orm/readings/reading-05-validations-orm-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "validations-with-sequelize"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Model Validations With Sequelize\n\nIt's important to make sure that data stored to a database is not\nerroneous or incomplete. Imagine the following forms of \"garbage data:\"\n\n* A `Cats` record with `firstName` set to `NULL`. All `Cats` ought to\n  have a name.\n* A `Cats` record with `firstName` set to the empty string: `\"\"`.\n* A `Cats` record with an `age` less than `0`. `age` must always be\n  non-negative.\n* Perhaps the `specialSkill` should come from a pre-defined limited list\n  of `[\"jumping\", \"sleeping\", \"purring\"]`. A `Cats` record with a\n  `specialSkill` of `\"pearl diving\"` would thus be invalid.\n\nSequelize lets us write JavaScript code that will check that these data\nrequirements are satisfied before saving a record to the database. The\nJavaScript code that does this is called a _validation_. A validation is\ncode that makes sure that data is valid.\n\nIn this reading you will learn how to:\n\n1. Validate that an attribute is not set to `NULL`.\n2. Validate that a string attribute is not set to the empty string `\"\"`.\n3. Validate that a string attribute is not too long (has too many\n   characters).\n3. Validate that a numeric attribute meets minimum or maximum\n   thresholds.\n4. Validate that an attribute is within a limited set of options.\n\n## Validating That An Attribute Is Not `NULL`\n\nWe should not allow a `Cat` to be saved to the database if it lacks\n\n1. a `firstName`,\n1. an `age`, or\n3. a `specialSkill`.\n\nNone of these should be set to `NULL`.\n\nBefore adding validations to check these requirements, let's review what\nour `Cat` model code currently looks like:\n\n```javascript\n// ./models/cat.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    firstName: DataTypes.STRING,\n    specialSkill: DataTypes.STRING,\n    age: DataTypes.INTEGER,\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nWe will modify our model definition to give more specific instructions\nto Sequelize about the `firstName`, `specialSkill`, and `age`\nattributes:\n\n```javascript\n// ./models/cat.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    firstName: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"firstName must not be null\",\n        },\n      },\n    },\n    specialSkill: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"specialSkill must not be null\",\n        },\n      },\n    },\n    age: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"age must not be null\",\n        },\n      },\n    },\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nWhat has changed? We now map each attribute name (`firstName`,\n`specialSkill`, `age`) to a POJO that tells Sequelize how to configure\nthat attribute. Here is the POJO for `firstName`:\n\n```javascript\n{\n  type: DataTypes.STRING,\n  allowNull: false,\n  validate: {\n    notNull: {\n      msg: \"firstName must not be null\",\n    },\n  },\n}\n```\n\nThe `type` attribute is of course vital: this used to be the only thing\nwe specified. We've added two new attributes. The first is `allowNull:\nfalse`. This tells Sequelize not to let us set the `firstName` attribute\nto `NULL`.\n\nThe second attribute is `validate`. We will spend a lot of time\nexamining this attribute in this reading. Validation logic for\n`firstName` is configured inside the `validate` attribute. Our\n`validate` configuration is:\n\n```javascript\n{\n  notNull: {\n    msg: \"firstName must not be null\",\n  },\n}\n```\n\nThis configuration tells Sequelize what error message to give if we try\nto set the `firstName` attribute to `NULL`. It's odd that we have to set\nboth `allowNull: false` and `notNull: { msg:  ... }`. This feels like\nunnecessary duplication. Regardless, that's what Sequelize wants us to\ndo. On the other hand, we do get a chance to specify the error message\nto print if the validation fails (`\"firstName must not be null\"`).\n\nLet's see how the validation logic helps us avoid saving junk data to\nour database:\n\n```javascript\n// index.js\nconst { sequelize, Cat } = require(\"./models\");\n\nasync function main() {\n  const cat = Cat.build({\n    // Empty cat. All fields set to `null`.\n  });\n\n  try {\n    // Try to save cat to the database.\n    await cat.save();\n\n    console.log(\"Save success!\");\n    console.log(JSON.stringify(cat, null, 2));\n  } catch (err) {\n    console.log(\"Save failed!\");\n\n    // Print list of errors.\n    for (const validationError of err.errors) {\n      console.log(\"*\", validationError.message);\n    }\n  }\n\n  await sequelize.close();\n}\n\nmain()\n```\n\nRunning this code prints:\n\n```\nSave failed!\n* firstName must not be null\n* specialSkill must not be null\n* age must not be null\n```\n\nWhat happened? When we call the `save` method on a `Cat`, Sequelize will\ncheck that all the specified validations are satisfied. In this case\nnone of them are! The `save` method will throw an exception, which we\nhandle using `try { ... } catch (err) { ... }`.\n\nWhat kind of exception? The thrown error is a\n[`ValidationError`][validation-error-docs]. This has an `errors`\nattribute, which stores an array of\n[`ValidationErrorItem`s][validation-error-item-docs]. We print out the\nmessage for each item error.\n\nBecause there were validation failures, Sequelize **will not save** the\ninvalid `Cats` record to the database. Sequelize thus keeps us from\ninserting junk data into the database.\n\nIf we want to save our `Cat` object, we would have to change its\nattributes to meet the validations (i.e., set them to something other\nthan `NULL`) and call `save` a second time. For example:\n\n```javascript\n// index.js\nconst { sequelize, Cat } = require(\"./models\");\n\nasync function main() {\n  const cat = Cat.build({\n    // Empty cat. All fields set to `null`.\n  });\n\n  try {\n    await cat.save();\n  } catch (err) {\n    // The save will not succeed!\n    console.log(\"We will fix and try again!\");\n  }\n\n  // Fix the various validation problems.\n  cat.firstName = \"Markov\";\n  cat.specialSkill = \"sleeping\";\n  cat.age = 4;\n\n  try {\n    // Trying to save a second time!\n    await cat.save();\n\n    console.log(\"Success!\");\n  } catch (err) {\n    // The save *should* succeed!\n    console.log(err);\n  }\n\n  await sequelize.close();\n}\n\nmain()\n```\n\n[validation-error-docs]: https://sequelize.org/v5/class/lib/errors/validation-error.js~ValidationError.html\n[validation-error-item-docs]: https://sequelize.org/v5/class/lib/errors/validation-error.js~ValidationErrorItem.html\n\n## The `notEmpty` Validation\n\nEven though we are not allowed to set `firstName` and `specialSkill` to\n`NULL`, we could still set them to the empty string `\"\"`:\n\n```javascript\n// index.js\nconst { sequelize, Cat } = require(\"./models\");\n\nasync function main() {\n  const cat = Cat.build({\n    firstName: \"\",\n    specialSkill: \"\",\n    age: 5,\n  });\n\n  try {\n    // Try to save cat to the database.\n    await cat.save();\n\n    console.log(\"Save success!\");\n    console.log(JSON.stringify(cat, null, 2));\n  } catch (err) {\n    console.log(\"Save failed!\");\n\n    // Print list of errors.\n    for (const validationError of err.errors) {\n      console.log(\"*\", validationError.message);\n    }\n  }\n\n  await sequelize.close();\n}\n\nmain();\n```\n\n```\nExecuting (default): INSERT INTO \"Cats\" (\"id\",\"firstName\",\"specialSkill\",\"age\",\"createdAt\",\"updatedAt\") VALUES (DEFAULT,$1,$2,$3,$4,$5) RETURNING *;\nSave success!\n{\n  \"id\": 8,\n  \"firstName\": \"\",\n  \"specialSkill\": \"\",\n  \"age\": 5,\n  \"updatedAt\": \"2020-02-12T21:34:49.250Z\",\n  \"createdAt\": \"2020-02-12T21:34:49.250Z\"\n}\n```\n\nThis is bogus: `Cats` records should have a non-empty `firstName` and\n`specialSkill`. We will therefore add a second validation for both\n`firstName` and `specialSkill`:\n\n```javascript\n// ./models/cat.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    firstName: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"firstName must not be null\",\n        },\n        notEmpty: {\n          msg: \"firstName must not be empty\",\n        },\n      },\n    },\n    specialSkill: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"specialSkill must not be null\",\n        },\n        notEmpty: {\n          msg: \"specialSkill must not be empty\",\n        },\n      },\n    },\n    // ...\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nWhen we run the same `index.js` that tries to save the `Cats` record\nwith the empty `firstName` and `specialSkill`, we now print:\n\n```\nSave failed!\n* firstName must not be empty\n* specialSkill must not be empty\n```\n\nExcellent! We've added the new validation by adding a `notEmpty` key to\nthe `validate` POJO. Just like with `notNull`, we specify a message to\nprint.\n\nThis is the typical story: we add new validations by adding new\nkey/value pairs to the `validate` POJO. Sequelize provides many\ndifferent kinds of validations for us, but we configure all of them in\nthe same general manner.\n\n## Forbidding Long String Values\n\nWe don't want our cats to have names that are too long. We add a `len`\nvalidation like so:\n\n```javascript\n// ./models/cat.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    firstName: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"firstName must not be null\",\n        },\n        notEmpty: {\n          msg: \"firstName must not be empty\",\n        },\n        len: {\n          args: [0, 8],\n          msg: \"firstName must not be more than eight letters long\",\n        },\n      },\n    },\n    // ...\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nIf we try to run:\n\n```javascript\n// index.js\nconst { sequelize, Cat } = require(\"./models\");\n\nasync function main() {\n  const cat = Cat.build({\n    firstName: \"Markov The Magnificent\",\n    specialSkill: \"sleeping\",\n    age: 5,\n  });\n\n  try {\n    // Try to save cat to the database.\n    await cat.save();\n\n    console.log(\"Save success!\");\n    console.log(JSON.stringify(cat, null, 2));\n  } catch (err) {\n    console.log(\"Save failed!\");\n\n    // Print list of errors.\n    for (const validationError of err.errors) {\n      console.log(\"*\", validationError.message);\n    }\n  }\n\n  await sequelize.close();\n}\n\nmain();\n```\n\nWe will be told:\n\n```\nSave failed!\n* firstName must not be more than eight letters long\n```\n\nThe `len` validation gets a `msg` attribute as usual. We also configure\n`args: [0, 8]`. These are the \"arguments\" to the `len` validation. We\nare telling Sequelize to trigger a validation error if the `firstName`\nproperty has a length less than zero (impossible) or greater than eight.\n\nNote that even though the `len` validation is not triggered for a length\nof zero, the `notEmpty` validation still will be.\n\nIf desired, we could use the `len` validation to set a true minimum\nlength for a string. If we wanted a minimum length of two letters, we\nwould just change `args: [2, 8]`. (We ought also update the `msg`\nappropriately.)\n\n## Validating That A Numeric Value Is Within A Specified Range\n\nA `Cat` should never have a negative age. Perhaps, also, a `Cat` should\nhave a theoretical maximum age of 99 years. We can add validations to\nenforce these requirements:\n\n```javascript\n// ./models/cat.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    // ...\n    age: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"age must not be null\",\n        },\n        min: {\n          args: [0],\n          msg: \"age must not be less than zero\",\n        },\n        max: {\n          args: [99],\n          msg: \"age must not be greater than 99\",\n        },\n      },\n    },\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nYou can see that the `min` and `max` validations are configured in the\nsame sort of way that the `len` validation is.\n\nIf we try to save a `Cat` with an `age` of `-1`, we are printed:\n\n```\nSave failed!\n* age must not be less than zero\n```\n\nLikewise, if we try to save a `Cat` with an `age` of `123` we are\nprinted:\n\n```\nSave failed!\n* age must not be greater than 99\n```\n\n*(Note: I've stopped repeating our `index.js` file, since there are only\ntrivial modifications to a `Cat`'s attributes each time.)*\n\n## Validating That An Attribute Is Among A Finite Set Of Values\n\nLet's say that a `Cat`'s `specialSkill` should be restricted to a\npre-defined list of `[\"jumping\", \"sleeping\", \"purring\"]`. That is: a\n`Cat` should not be allowed to have just any `specialSkill`. The\n`specialSkill` must be on the list.\n\nWe can enforce this requirement like so:\n\n```javascript\n// ./models/cat.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    // ...\n    specialSkill: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      validate: {\n        notNull: {\n          msg: \"specialSkill must not be null\",\n        },\n        notEmpty: {\n          msg: \"specialSkill must not be empty\",\n        },\n        isIn: {\n          args: [[\"jumping\", \"sleeping\", \"purring\"]],\n          msg: \"specialSkill must be either jumping, sleeping, or purring\",\n        },\n      },\n    },\n    // ...\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nNotice how we **doubly-nest** the list of special skills (`[\"jumping,\n\"sleeping\", \"purring\"]`) when specifying the `args` for the `isIn`\nvalidation. This is because we want to pass **one** argument: an array\nof three possible special skills.\n\nNow when we try to save a `Cat` with `specialSkill` set to `\"pearl\ndiving\"`, our code will print:\n\n```\nSave failed!\n* specialSkill must be either jumping, sleeping, or purring\n```\n\n## Conclusion\n\nThere is a very large variety of validations that are provided by\nSequelize. You can find many more in the Sequelize [documentation for\nvalidations][validation-docs].\n\n[validation-docs]: https://sequelize.org/v5/manual/models-definition.html#validations\n\nHaving completed this reading, you now know how to:\n\n1. Validate that an attribute is not set to `NULL`.\n2. Validate that a string attribute is not set to the empty string `\"\"`.\n3. Validate that a string attribute is not too long (has too many\n   characters).\n3. Validate that a numeric attribute meets minimum or maximum\n   thresholds.\n4. Validate that an attribute is within a limited set of options.\n"
  },
  "success": true
}