{
  "template": {
    "taskId": "4bc45a41-a46d-43c3-90c0-1dfadd8beade",
    "name": "Table Management Walk-Through Part 2",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/sql/readings/reading-05-creating-tables-ii-sql.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "table-management-walk-through-part-2"
    ],
    "topic": "Monday - Hello, Database!",
    "subtopic": "Lecture",
    "body": "# Table Management -  Part II\n\n**This is a walk-through**: Please type along as you read what's going on in\nthis article.\n\nIn this walk-through, you will\n\n* Learn about nullable columns,\n* Learn about default values for columns,\n* Learn how to make columns have unique values,\n* Learn about primary keys, and,\n* Learn about relating tables through foreign keys to maintain data and\n  referential integrity.\n\nHere is the \"puppies\" spreadsheet, table definition, and the SQL to create it\nfrom the last article.\n\n![Puppies spreadsheet]\n\n| Column       | JavaScript data type | Max length | ANSI SQL data type |\n|--------------|----------------------|------------|--------------------|\n| name         | string               | 50         | VARCHAR(50)        |\n| age_yrs      | number               |            | NUMERIC(3,1)       |\n| breed        | string               | 100        | VARCHAR(100)       |\n| weight_lbs   | number               |            | INTEGER            |\n| microchipped | Boolean              |            | BOOLEAN            |\n\n```sql\nCREATE TABLE puppies (\n  name VARCHAR(50),\n  age_yrs NUMERIC(3,1),\n  breed VARCHAR(100),\n  weight_lbs INTEGER,\n  microchipped BOOLEAN\n);\n```\n\nIn this article, you will add more specifications to this table so that you can\nproperly use it. Then, you will refactor it into two tables that relate to one\nanother.\n\n## Nullable columns\n\nBy default, when you define a table, each column does not require a value when\nyou create a record (row). Look at the spreadsheet. You can see all of the rows\nin it have data in every column. The SQL that you wrote does not enforce that.\n\nThe value `NULL` is a strange value because it means _the absence of a value_.\nWhen a value in a row is `NULL`, that means that it didn't get entered. Many\ndatabase administrators, experts in databases and the models of data in them,\ndetest the value `NULL` for one reason: it adds a weird state.\n\nThink about a Boolean value in JavaScript. It can one of two values: `true` or\n`false`. In databases, a \"nullable\" `BOOLEAN` column, that is a `BOOLEAN` column\nthat can hold `NULL` values, can have _three_ values in it: `TRUE`, `FALSE`, and\n`NULL`. What does that mean to you as a software developer? It is this weird\nthird state that leads to a strange offshoot of mathematics named [three-valued\nlogic]. To prevent that, you should (nearly) always put the `NOT NULL`\nconstraint on each of your column definitions. That will make your previous SQL\nstatement look like this.\n\n```sql\nCREATE TABLE puppies (\n  name VARCHAR(50) NOT NULL,\n  age_yrs NUMERIC(3,1) NOT NULL,\n  breed VARCHAR(100) NOT NULL,\n  weight_lbs INTEGER NOT NULL,\n  microchipped BOOLEAN NOT NULL\n);\n```\n\nType that SQL into your `psql` shell and execute it. (If you already have a\n\"puppies\" table, drop the existing one first.) Then, run `\\d puppies`. You\nwill see, now, that the column \"Nullable\" reads \"not null\" for every single one.\n\n```\n                         Table \"public.puppies\"\n    Column    |          Type          | Collation | Nullable | Default\n--------------+------------------------+-----------+----------+---------\n name         | character varying(50)  |           | not null |\n age_yrs      | numeric(3,1)           |           | not null |\n breed        | character varying(100) |           | not null |\n weight_lbs   | integer                |           | not null |\n microchipped | boolean                |           | not null |\n```\n\nNow, when someone tries to add data to the table, they must provide a value for\nevery single column.\n\n**Note**: An empty string is _not_ a `NULL` value. It is still possible for\nsomeone to insert the string \"\" into the \"name\" column, for example. There are\nways to prevent that, but you should check it in your JavaScript code before\nactually inserting the data.\n\n## Default values\n\nSometimes, you just want a column to have a default value. When there is a\ndefault value, the applications that insert data into the table can just rely\non the default value and not have to specify it.\n\nFor the \"puppies\" table, a reasonable default value for the \"microchipped\"\ncolumn would be `FALSE`. You can add that to your SQL using the `DEFAULT`\nkeyword.\n\n```sql\nCREATE TABLE puppies (\n  name VARCHAR(50) NOT NULL,\n  age_yrs NUMERIC(3,1) NOT NULL,\n  breed VARCHAR(100) NOT NULL,\n  weight_lbs INTEGER NOT NULL,\n  microchipped BOOLEAN NOT NULL DEFAULT FALSE\n);\n```\n\nDrop the existing \"puppies\" table and type in that SQL. Then, run `\\d puppies`\nto see how it shows up in the table definition.\n\n## Primary keys\n\nBeing able to identify a single row in a table is _very_ important. Here's the\nscreenshot of the spreadsheet, again.\n\n![Puppies spreadsheet]\n\nLet's say that the puppy named \"Max\" gains a couple of pounds. You want to\nupdate the spreadsheet. You scan through the list of names and find it on row\n11. Then, you update the weight to be 69 pounds.\n\nNow, what happens when you are tracking 300 dogs in the spreadsheet? What\nhappens when your spreadsheet has 17 dogs named \"Max\"? It is helpful to have\nsome way to uniquely identify a row in the spreadsheet. This is the idea behind\na **primary key**. You can specify a column to be the primary key with the\nkeywords `PRIMARY KEY`. A column that acts as a primary key cannot be `NULL`, so\nthat is implied.\n\nHere's the spreadsheet with a new column in it named \"id\" that just contains\nnumbers to uniquely identify each row.\n\n![Puppies spreadsheet with primary key]\n\nYou may ask yourself, \"Why can't I just use the row number as each row's\nidentifier?\" That's a very valid question! Here is the reason why. You can see\nthat \"Max\" has an \"id\" of 10 on row 11. What happens if you wanted to look at\nthe data differently, say sorted by name? Here's what that spreadsheet looks\nlike.\n\n![Puppies spreadsheet with primary key sorted by name]\n\nYou can see that when you sort them by name, if you relied on row number, \"Max\"\nnow lives on row 10 rather than row 11. That changes the unique identifer of\n\"Max\" based on the way that you view the data. You want the unique identifier to\n_be part of the row definition_ so that the number always stays with the row no\nmatter how you've sorted the data. You will always know that the row with \"id\"\nvalue of 10 is \"Max\".\n\nKeeping track of what the next number would be in that column could cause you a\nlot or headaches. What if two people (or applications) were entering data at the\nsame time? Who would get the correct \"next id\" and still have it be unique? The\nanswer to that is to let the database handle it. All databases have some way of\nspecifying that you want to set the column to a special data type that will\nauto-assign and auto-increment an integer value for the column. In PostgreSQL,\nthat special data type is called `SERIAL`.\n\nPutting that all together, you would add a new column definition to your table\nwith the name of \"id\" and the type `SERIAL`. Then, to specify that it is the\nprimary key, you can do it one of two ways. The following example shows it as\npart of the column definition.\n\n```sql\nCREATE TABLE puppies (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  age_yrs NUMERIC(3,1) NOT NULL,\n  breed VARCHAR(100) NOT NULL,\n  weight_lbs INTEGER NOT NULL,\n  microchipped BOOLEAN NOT NULL DEFAULT FALSE\n);\n```\n\nOr, you can put it in what is known as **constraint syntax** after the columns\nspecifications but before the close parenthesis.\n\n```sql\nCREATE TABLE puppies (\n  id SERIAL,\n  name VARCHAR(50) NOT NULL,\n  age_yrs NUMERIC(3,1) NOT NULL,\n  breed VARCHAR(100) NOT NULL,\n  weight_lbs INTEGER NOT NULL,\n  microchipped BOOLEAN NOT NULL DEFAULT FALSE,\n  PRIMARY KEY(id)\n);\n```\n\nEither way you do it, when you view the output of `\\d puppies`, you see some new\nthings in the output.\n\n```\n                                      Table \"public.puppies\"\n    Column    |          Type          | Collation | Nullable |               Default\n--------------+------------------------+-----------+----------+-------------------------------------\n id           | integer                |           | not null | nextval('puppies_id_seq'::regclass)\n name         | character varying(50)  |           | not null |\n age_yrs      | numeric(3,1)           |           | not null |\n breed        | character varying(100) |           | not null |\n weight_lbs   | integer                |           | not null |\n microchipped | boolean                |           | not null | false\nIndexes:\n    \"puppies_pkey\" PRIMARY KEY, btree (id)\n```\n\nFirst, you'll notice that there is a weird default value for the \"id\" column.\nThat's the way that PostgreSQL populates it with a new integer value every time\nyou add a new row.\n\nYou will also see that that there is a section named \"Indexes\" after the column\nspecifications. This shows that there is a thing named \"puppies_pkey\" which is\nthe primary key on the column \"id\".\n\n## Unique values\n\nSometimes, you want all of the data in a column to be unique. For example, if\nyou a table of people records. You want to collect their email address for them\nto sign up for your Web site. In general, people don't share email addresses\n(although it has been known to happen). You can put a constraint on a column by\nputting `UNIQUE` in the column's definition. For example, here's a sample\n\"people\" table with a unique constraint on the email column.\n\n```sql\nCREATE TABLE people (\n  id SERIAL,\n  first_name VARCHAR(50) NOT NULL,\n  last_name VARCHAR(50) NOT NULL,\n  email VARCHAR(250) NOT NULL UNIQUE,\n  PRIMARY KEY (id)\n);\n```\n\nWhen you use the `\\d people` command to view the definition of the table, you\nwill see this.\n\n```\n                                      Table \"public.people\"\n   Column   |          Type          | Collation | Nullable |              Default\n------------+------------------------+-----------+----------+------------------------------------\n id         | integer                |           | not null | nextval('people_id_seq'::regclass)\n first_name | character varying(50)  |           | not null |\n last_name  | character varying(50)  |           | not null |\n email      | character varying(250) |           | not null |\nIndexes:\n    \"people_pkey\" PRIMARY KEY, btree (id)\n    \"people_email_key\" UNIQUE CONSTRAINT, btree (email)\n```\n\nDown there at the bottom, you see that PostgreSQL has added a `UNIQUE\nCONSTRAINT` to the list of indexes for the \"email\" field. Now, if someone tried\nto put an email address into the table that someone had previously used, then\nthe database would return an error.\n\n```\nERROR:  duplicate key value violates unique constraint \"people_email_key\"\nDETAIL:  Key (email)=(a) already exists.\n```\n\n## Refactor for data integrity\n\nNow is the time for thinking about the nature of the data. When you create\ndatabase tables, you need to ask yourself about the data that you're going to\nstore in them. One of the first questions that you should ask yourself is, \"Do\nany of the columns have values that come from a list?\" Or, another way to ask\nthat is, \"Do any of the columns come from a set of predefined values?\" If you\nlook at this data, does anything seem like it comes from a list, or that the\ndata could repeat itself?\n\nTake a look, again, at the spreadsheet. Does anything jump out at you?\n\n![Puppies spreadsheet with primary key sorted by name]\n\nIf you looked at it and answered \"the breed column\", that's the ticket! The\nvalues that go into the breed column is finite. You don't want one person typing\n\"Corgi\" and another person typing \"CORGI\" and another \"corgi\" because, as you\nknow, those are _three different values_! You want them all to be the same\nvalue! Supporting this is the primary reason that relational databases exist.\n\nInstead of having just one table, you could have two tables. One that contains\nthe puppy information and another that contains the breed information. Then,\nusing the magic of relational databases, you can create a relation between the\ntwo tables so that the \"puppies\" table will reference entries in the \"breeds\"\ntable.\n\nThis process is called **normalization**. It's a _really big deal_ in database\ncommunities. And, it's a really big deal for application developers to maintain\nthe integrity of the data. Bad data leads to bad applications.\n\nTo do this follows a fairly simple set of steps.\n\n1. Figure out what related data repeats itself. In this case, it is only the\n   single column that contains the **breed** names.\n2. Create a new table to hold that data. Make sure it has a primary key. In this\n   case, you can create a \"breeds\" table that contains an \"id\" the name of the\n   breed.\n3. Replace all of the columns in the original table that you extracted with a\n   single value that will contain the corresponding \"id\" value from the new\n   table. In this case, you will replace the \"breed\" column with a column named\n   \"breed_id\" because it will have the id of the specific breed from the\n   \"breeds\" table.\n\nHere's what that would look like with two spreadsheets.\n\n![Puppies and breed spreadsheets normalized]\n\nYou might think to yourself, \"That's not simpler! That's ... that's harder!\"\nFrom a human perspective looking at the two separate tables and associating the\nid in the \"breed_id\" column with the value in the \"id\" column of the \"breeds\"\ntable to lookup the name of the breed _is_ harder. But, SQL provides tools to\nmake this _very easy_. You will learn about that in the homework, tonight, and\nin all of the database work that you'll be doing from here on out. Eventually,\nthinking this way about data will become second nature.\n\nTo represent this in SQL, you will need two SQL statements. The first one, the\none for the \"breeds\" table, you should be able to construct that already with\nthe knowledge that you have. It would look like this. Type this into your\n`plsql` shell.\n\n```sql\nCREATE TABLE breeds (\n  id SERIAL,\n  name VARCHAR(50) NOT NULL,\n  PRIMARY KEY (id)\n);\n```\n\nNow, here's the new thing. You want the database to make sure that the value in\nthe \"breed_id\" column of the \"puppies\" table references the value in the \"id\"\ntable of the \"breeds\" table. This reference is called a **foreign key**. That\nmeans that the value in the column _must exist_ as the value of a primary key in\nthe table that it references. This **referential integrity** is the backbone of\nrelational databases. It prevents bad data from getting put into those foreign\nkey columns.\n\nHere's what the new \"puppies\" SQL looks like. Drop the old \"puppies\" table and\ntype this SQL in there.\n\n```sql\nCREATE TABLE puppies (\n  id SERIAL,\n  name VARCHAR(50) NOT NULL,\n  age_yrs NUMERIC(3,1) NOT NULL,\n  breed_id INTEGER NOT NULL,\n  weight_lbs INTEGER NOT NULL,\n  microchipped BOOLEAN NOT NULL DEFAULT FALSE,\n  PRIMARY KEY(id),\n  FOREIGN KEY (breed_id) REFERENCES breeds(id)\n);\n```\n\nThat new thing at the bottom of the definition, that's how you relate one table\nto another. If follows the syntax\n\n```sql\nFOREIGN KEY («column name in this table»)\n  REFERENCES «other table name»(«primary key column in other table»)\n```\n\nLooking at the spreadsheets, again, the presence of the foreign key would make\nit _impossible_ for someone to enter a value in the \"breed_id\" column that did\nnot exist in the \"id\" column of the \"breeds\" table.\n\n![Puppies and breed spreadsheets normalized]\n\nYou can see that the puppies with ids of 1 and 9, \"Cooper\" and \"Leinni\", both\nhave the \"breed_id\" of 8. That means they're both \"Miniature Schnauzers\". What\nif, originally, someone had misspelled \"Schnauzers\"? If it was still just a text\ncolumn in the \"puppies\" sheet, you'd have to go find and replace every single\ninstance of the misspelling. Now, because it's only spelled once and then\n_referenced_, you would only need to update the misspelling in one place!\n\n## Order of table declarations\n\nThe order of running these table definitions is important. Because \"puppies\"\nnow relies on \"breeds\" to exist for that foreign key relationship, you _must_\ncreate the \"breeds\" table first. If you had tried to create the \"puppies\" table\nfirst, you would see the following error message.\n\n```\nERROR: relation \"breeds\" does not exist\n```\n\nNow that you have both of those tables in your database, what do you think would\nhappen if you tried to drop the \"breeds\" table? Another table depends on it.\nWhen you tried to drop a user that owned a database, you got an error because\nthat database object depended on that user existing, the same things happens\nnow.\n\nType the SQL to drop the \"breeds\" table from the database. You should see the\nfollowing error message.\n\n```\nERROR:  cannot drop table breeds because other objects depend on it\nDETAIL:  constraint puppies_breed_id_fkey on table puppies depends on table breeds\nHINT:  Use DROP ... CASCADE to drop the dependent objects too.\n```\n\nYou can see that PostgreSQL has told you that other things depend on the\n\"breeds\" table and, specifically, a thing called \"puppies_breed_id_fkey\" depends\non it. That is the auto-generated name for the foreign key that you created\nin the \"puppies\" table. It took the name of the table, the name of the column,\nand the string \"fkey\" and joined them all together with underscores.\n\nIn the homework for tomorrow, you will see how to _join_ together two tables\ninto one virtual table so that the breed names are right there along with the\npuppies data.\n\n## What you've done\n\nIn this walk-through, you\n\n* Learned about nullable columns and how to control that behavior by writing\n  `NOT NULL` in your column specifications\n* Learned that `NULL` means an \"absence of a value\" which makes database\n  administrators groan with displeasure\n* Learned about how to specify default values for a column\n* Learned the purpose of and how to declare integer-valued primary keys for a\n  table using the `PRIMARY KEY` constraint and `SERIAL` data type\n* Learned about _normalization_ and the steps to refactor a table to remove\n  duplicated data\n* Learned the purpose of and how to declare foreign keys to relate the column of\n  one table to the primary key of another table\n\n\n[Puppies spreadsheet]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/tables-puppies-spreadsheet.png\n[three-valued logic]: https://en.wikipedia.org/wiki/Three-valued_logic\n[Puppies spreadsheet with primary key]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/spreadsheet-puppies-with-primary-key.png\n[Puppies spreadsheet with primary key sorted by name]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/spreadsheet-puppies-with-primary-key-sorted-by-name.png\n[Puppies and breed spreadsheets normalized]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/spreadsheet-puppies-and-breeds-normalized.png\n"
  },
  "success": true
}