<h1 id="sequelize">Sequelize</h1>
<blockquote>
<p>An easy-to-use multi SQL dialect ORM for Node.js</p>
</blockquote>
<p>Below are some of the datatypes supported by sequelize. For a full and updated list, see <a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/master/variable/index.html#static-variable-DataTypes">DataTypes</a>.</p>
<pre><code>Sequelize.STRING                      // VARCHAR(255)
Sequelize.STRING(1234)                // VARCHAR(1234)
Sequelize.STRING.BINARY               // VARCHAR BINARY
Sequelize.TEXT                        // TEXT
Sequelize.TEXT(&#39;tiny&#39;)                // TINYTEXT
Sequelize.CITEXT                      // CITEXT      PostgreSQL and SQLite only.

Sequelize.INTEGER                     // INTEGER
Sequelize.BIGINT                      // BIGINT
Sequelize.BIGINT(11)                  // BIGINT(11)

Sequelize.FLOAT                       // FLOAT
Sequelize.FLOAT(11)                   // FLOAT(11)
Sequelize.FLOAT(11, 10)               // FLOAT(11,10)

Sequelize.REAL                        // REAL        PostgreSQL only.
Sequelize.REAL(11)                    // REAL(11)    PostgreSQL only.
Sequelize.REAL(11, 12)                // REAL(11,12) PostgreSQL only.

Sequelize.DOUBLE                      // DOUBLE
Sequelize.DOUBLE(11)                  // DOUBLE(11)
Sequelize.DOUBLE(11, 10)              // DOUBLE(11,10)

Sequelize.DECIMAL                     // DECIMAL
Sequelize.DECIMAL(10, 2)              // DECIMAL(10,2)

Sequelize.DATE                        // DATETIME for mysql / sqlite, TIMESTAMP WITH TIME ZONE for postgres
Sequelize.DATE(6)                     // DATETIME(6) for mysql 5.6.4+. Fractional seconds support with up to 6 digits of precision
Sequelize.DATEONLY                    // DATE without time.
Sequelize.BOOLEAN                     // TINYINT(1)

Sequelize.ENUM(&#39;value 1&#39;, &#39;value 2&#39;)  // An ENUM with allowed values &#39;value 1&#39; and &#39;value 2&#39;
Sequelize.ARRAY(Sequelize.TEXT)       // Defines an array. PostgreSQL only.
Sequelize.ARRAY(Sequelize.ENUM)       // Defines an array of ENUM. PostgreSQL only.

Sequelize.JSON                        // JSON column. PostgreSQL, SQLite and MySQL only.
Sequelize.JSONB                       // JSONB column. PostgreSQL only.

Sequelize.BLOB                        // BLOB (bytea for PostgreSQL)
Sequelize.BLOB(&#39;tiny&#39;)                // TINYBLOB (bytea for PostgreSQL. Other options are medium and long)

Sequelize.UUID                        // UUID datatype for PostgreSQL and SQLite, CHAR(36) BINARY for MySQL (use defaultValue: Sequelize.UUIDV1 or Sequelize.UUIDV4 to make sequelize generate the ids automatically)

Sequelize.CIDR                        // CIDR datatype for PostgreSQL
Sequelize.INET                        // INET datatype for PostgreSQL
Sequelize.MACADDR                     // MACADDR datatype for PostgreSQL

Sequelize.RANGE(Sequelize.INTEGER)    // Defines int4range range. PostgreSQL only.
Sequelize.RANGE(Sequelize.BIGINT)     // Defined int8range range. PostgreSQL only.
Sequelize.RANGE(Sequelize.DATE)       // Defines tstzrange range. PostgreSQL only.
Sequelize.RANGE(Sequelize.DATEONLY)   // Defines daterange range. PostgreSQL only.
Sequelize.RANGE(Sequelize.DECIMAL)    // Defines numrange range. PostgreSQL only.

Sequelize.ARRAY(Sequelize.RANGE(Sequelize.DATE)) // Defines array of tstzrange ranges. PostgreSQL only.

Sequelize.GEOMETRY                    // Spatial column.  PostgreSQL (with PostGIS) or MySQL only.
Sequelize.GEOMETRY(&#39;POINT&#39;)           // Spatial column with geometry type. PostgreSQL (with PostGIS) or MySQL only.
Sequelize.GEOMETRY(&#39;POINT&#39;, 4326)     // Spatial column with geometry type and SRID.  PostgreSQL (with PostGIS) or MySQL only.</code></pre>
<p>The BLOB datatype allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column, that data will always be returned as a buffer.</p>
<p>If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library’s own parser:</p>
<pre><code>require(&#39;pg&#39;).types.setTypeParser(1114, stringValue =&gt; {
  return new Date(stringValue + &#39;+0000&#39;);
  // e.g., UTC offset. Use any offset that you would like.
});</code></pre>
<p>In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL!</p>
<pre><code>Sequelize.INTEGER.UNSIGNED              // INTEGER UNSIGNED
Sequelize.INTEGER(11).UNSIGNED          // INTEGER(11) UNSIGNED
Sequelize.INTEGER(11).ZEROFILL          // INTEGER(11) ZEROFILL
Sequelize.INTEGER(11).ZEROFILL.UNSIGNED // INTEGER(11) UNSIGNED ZEROFILL
Sequelize.INTEGER(11).UNSIGNED.ZEROFILL // INTEGER(11) UNSIGNED ZEROFILL</code></pre>
<p><em>The examples above only show integer, but the same can be done with bigint and float</em></p>
<p>Usage in object notation:</p>
<pre><code>// for enums:
class MyModel extends Model {}
MyModel.init({
  states: {
    type: Sequelize.ENUM,
    values: [&#39;active&#39;, &#39;pending&#39;, &#39;deleted&#39;]
  }
}, { sequelize })</code></pre>
<h3 id="arrayenum">Array(ENUM)</h3>
<p>Its only supported with PostgreSQL.</p>
<p>Array(Enum) type require special treatment. Whenever Sequelize will talk to database it has to typecast Array values with ENUM name.</p>
<p>So this enum name must follow this pattern <code>enum_&lt;table_name&gt;_&lt;col_name&gt;</code>. If you are using <code>sync</code> then correct name will automatically be generated.</p>
<h3 id="range-types">Range types</h3>
<p>Since range types have extra information for their bound inclusion/exclusion it’s not very straightforward to just use a tuple to represent them in javascript.</p>
<p>When supplying ranges as values you can choose from the following APIs:</p>
<pre><code>// defaults to &#39;[&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;)&#39;
// inclusive lower bound, exclusive upper bound
Timeline.create({ range: [new Date(Date.UTC(2016, 0, 1)), new Date(Date.UTC(2016, 1, 1))] });

// control inclusion
const range = [
  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },
  { value: new Date(Date.UTC(2016, 1, 1)), inclusive: true },
];
// &#39;(&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;]&#39;

// composite form
const range = [
  { value: new Date(Date.UTC(2016, 0, 1)), inclusive: false },
  new Date(Date.UTC(2016, 1, 1)),
];
// &#39;(&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;)&#39;

Timeline.create({ range });</code></pre>
<p>However, please note that whenever you get back a value that is range you will receive:</p>
<pre><code>// stored value: (&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;]
range // [{ value: Date, inclusive: false }, { value: Date, inclusive: true }]</code></pre>
<p>You will need to call reload after updating an instance with a range type or use <code>returning: true</code> option.</p>
<h4 id="special-cases">Special Cases</h4>
<pre><code>// empty range:
Timeline.create({ range: [] }); // range = &#39;empty&#39;

// Unbounded range:
Timeline.create({ range: [null, null] }); // range = &#39;[,)&#39;
// range = &#39;[,&quot;2016-01-01 00:00:00+00:00&quot;)&#39;
Timeline.create({ range: [null, new Date(Date.UTC(2016, 0, 1))] });

// Infinite range:
// range = &#39;[-infinity,&quot;2016-01-01 00:00:00+00:00&quot;)&#39;
Timeline.create({ range: [-Infinity, new Date(Date.UTC(2016, 0, 1))] });</code></pre>
<h2 id="extending-datatypes">Extending datatypes</h2>
<p>Most likely the type you are trying to implement is already included in <a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/manual/data-types.html">DataTypes</a>. If a new datatype is not included, this manual will show how to write it yourself.</p>
<p>Sequelize doesn’t create new datatypes in the database. This tutorial explains how to make Sequelize recognize new datatypes and assumes that those new datatypes are already created in the database.</p>
<p>To extend Sequelize datatypes, do it before any instance is created. This example creates a dummy <code>NEWTYPE</code> that replicates the built-in datatype <code>Sequelize.INTEGER(11).ZEROFILL.UNSIGNED</code>.</p>
<pre><code>// myproject/lib/sequelize.js

const Sequelize = require(&#39;Sequelize&#39;);
const sequelizeConfig = require(&#39;../config/sequelize&#39;)
const sequelizeAdditions = require(&#39;./sequelize-additions&#39;)

// Function that adds new datatypes
sequelizeAdditions(Sequelize)

// In this exmaple a Sequelize instance is created and exported
const sequelize = new Sequelize(sequelizeConfig)

module.exports = sequelize


// myproject/lib/sequelize-additions.js

module.exports = function sequelizeAdditions(Sequelize) {

  DataTypes = Sequelize.DataTypes

  /*
   * Create new types
   */
  class NEWTYPE extends DataTypes.ABSTRACT {
    // Mandatory, complete definition of the new type in the database
    toSql() {
      return &#39;INTEGER(11) UNSIGNED ZEROFILL&#39;
    }

    // Optional, validator function
    validate(value, options) {
      return (typeof value === &#39;number&#39;) &amp;&amp; (! Number.isNaN(value))
    }

    // Optional, sanitizer
    _sanitize(value) {
      // Force all numbers to be positive
      if (value &lt; 0) {
        value = 0
      }

      return Math.round(value)
    }

    // Optional, value stringifier before sending to database
    _stringify(value) {
      return value.toString()
    }

    // Optional, parser for values received from the database
    static parse(value) {
      return Number.parseInt(value)
    }
  }

  DataTypes.NEWTYPE = NEWTYPE;

  // Mandatory, set key
  DataTypes.NEWTYPE.prototype.key = DataTypes.NEWTYPE.key = &#39;NEWTYPE&#39;

  // Optional, disable escaping after stringifier. Not recommended.
  // Warning: disables Sequelize protection against SQL injections
  // DataTypes.NEWTYPE.escape = false

  // For convenience
  // `classToInvokable` allows you to use the datatype without `new`
  Sequelize.NEWTYPE = Sequelize.Utils.classToInvokable(DataTypes.NEWTYPE)

}</code></pre>
<p>After creating this new datatype, you need to map this datatype in each database dialect and make some adjustments.</p>
<h2 id="postgresql">PostgreSQL</h2>
<p>Let’s say the name of the new datatype is <code>pg_new_type</code> in the postgres database. That name has to be mapped to <code>DataTypes.NEWTYPE</code>. Additionally, it is required to create a child postgres-specific datatype.</p>
<pre><code>// myproject/lib/sequelize-additions.js

module.exports = function sequelizeAdditions(Sequelize) {

  DataTypes = Sequelize.DataTypes

  /*
   * Create new types
   */

  ...

  /*
   * Map new types
   */

  // Mandatory, map postgres datatype name
  DataTypes.NEWTYPE.types.postgres = [&#39;pg_new_type&#39;]

  // Mandatory, create a postgres-specific child datatype with its own parse
  // method. The parser will be dynamically mapped to the OID of pg_new_type.
  PgTypes = DataTypes.postgres

  PgTypes.NEWTYPE = function NEWTYPE() {
    if (!(this instanceof PgTypes.NEWTYPE)) return new PgTypes.NEWTYPE();
    DataTypes.NEWTYPE.apply(this, arguments);
  }
  inherits(PgTypes.NEWTYPE, DataTypes.NEWTYPE);

  // Mandatory, create, override or reassign a postgres-specific parser
  //PgTypes.NEWTYPE.parse = value =&gt; value;
  PgTypes.NEWTYPE.parse = DataTypes.NEWTYPE.parse;

  // Optional, add or override methods of the postgres-specific datatype
  // like toSql, escape, validate, _stringify, _sanitize...

}</code></pre>
<h3 id="ranges">Ranges</h3>
<p>After a new range type has been <a href="https://www.postgresql.org/docs/current/static/rangetypes.html#RANGETYPES-DEFINING">defined in postgres</a>, it is trivial to add it to Sequelize.</p>
<p>In this example the name of the postgres range type is <code>newtype_range</code> and the name of the underlying postgres datatype is <code>pg_new_type</code>. The key of <code>subtypes</code> and <code>castTypes</code> is the key of the Sequelize datatype <code>DataTypes.NEWTYPE.key</code>, in lower case.</p>
<pre><code>// myproject/lib/sequelize-additions.js

module.exports = function sequelizeAdditions(Sequelize) {

  DataTypes = Sequelize.DataTypes

  /*
   * Create new types
   */

  ...

  /*
   * Map new types
   */

  ...

  /*
   * Add suport for ranges
   */

  // Add postgresql range, newtype comes from DataType.NEWTYPE.key in lower case
  DataTypes.RANGE.types.postgres.subtypes.newtype = &#39;newtype_range&#39;;
  DataTypes.RANGE.types.postgres.castTypes.newtype = &#39;pg_new_type&#39;;

}</code></pre>
<p>The new range can be used in model definitions as <code>Sequelize.RANGE(Sequelize.NEWTYPE)</code> or <code>DataTypes.RANGE(DataTypes.NEWTYPE)</code>.</p>
<p><a href="https://sequelize.org/v5/manual/data-types.html">Source</a></p>
