{
  "template": {
    "taskId": "56a429cc-d738-442b-aee9-972d2b969bd4",
    "name": "Recipe Box With Sequelize",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/orm/projects/project-5-sequelize-for-recipe-app/README.md",
    "type": "Project",
    "timeEstimate": 21600,
    "urls": [
      "recipe-box-with-sequelize"
    ],
    "topic": "Thursday - Sequelize ORM",
    "subtopic": "Practices",
    "download": "",
    "solution": "",
    "body": "# Recipe Box With Sequelize\n\nIn this project, you will build the Data Access Layer to power a Web\napplication. Unlike previously, you will use the Sequelize library and tools to\ndo this to build a more maintainable application.\n\nIt has more steps than the SQL version, but it's more maintainable in the long\nrun. Also, the SQL version hid a lot of complexity from you with respect to the\nrunning of the SQL. Go look at the SQL version of the files in the\n**controllers** directory to see what we had to do to load the SQL and execute\nit.\n\nNow, compare the _simplicity_ of those with the simplicity of the files in the\n**controllers** directory for _this_ version of the application. It's easier to\nunderstand _this_ version. You want to know where to add a column to a table?\nGo to the migrations. You want to know where to fix a query? Go to the proper\nrepository file.\n\nIt's just _so_ much better organized.\n\nQuite often, you will see that you will have more files and, overall, more lines\nof code in well-organized, highly-maintainable software project. Remembering\nwhere code is _is hard_. That's why having clearly-named files and directories\nis so very important.\n\n## The data model analysis\n\nThis looks no different because it's the same application.\n\nWhat goes into a recipe box? Why, recipes, of course! Here's an example recipe\ncard.\n\n![Recipe card]\n\nYou can see that a recipe is made up of three basic parts:\n\n* A title,\n* A list of ingredients, and\n* A list of instructions.\n\nYou're going to add a little more to that, too. It will also have\n\n* The date/time that it was entered into the recipe box, and\n* The date/time it was last updated in the recipe box.\n\nThese are good pieces of data to have so that you can show them \"most recent\"\nfor example.\n\nIngredients themselves are complex data types and need their own structure. They\n\"belong\" to a recipe. That means they'll need to reference that recipe. That\nmeans an ingredient is made up of:\n\n* An amount (optional),\n* A unit of measure (optional),\n* The actual food stuff, and\n* The id of the recipe that it belongs to.\n\nThat unit of measure is a good candidate for normalization, don't you think?\nIt's a predefined list of options that should not change and that you don't want\npeople just typing whatever they want in there, not if you want to maintain\ndata integrity. Otherwise, you'll end up with \"C\", \"c\", \"cup\", \"CUP\", \"Cup\", and\nall the other permutations, each of which is a distinct value but means the same\nthing.\n\nInstructions are also complex objects, but not by looking at them. Initially,\none might only see text that comprises an instruction. But, very importantly,\ninstructions have _order_. They also _belong_ to the recipe. With that in mind,\nan instruction is made up of:\n\n* The text of the instruction,\n* The order that it appears in the recipe, and\n* The id of the recipe that it belongs to.\n\nThat is enough to make a good model for the recipe box.\n\n![recipe box data model]\n\n## The application\n\nThe application is a standard [express.js] application using the [pug] library\nto generate the HTML and the [node-postgres] library to connect to the database.\n\nIt already has [sequelize] and [sequelize-cli] installed.\n\n## Getting started\n\n* Clone the starter project from\n  https://github.com/appacademy-starters/sql-orm-recipe-box\n* Run `npm install` to install the packages\n* Run `npm run dev` to start the server on port 3000\n\nYou'll do all of your work in the **data-access-layer** directory. In there, you\nwill find a series of JS files. Each of these will hold your JavaScript code\nrather than SQL code.\n\n## Your code\n\nYou're going to be using JavaScript and the tools of Sequelize. Keep the\n[Sequelize documentation] open and handy. Even developers that use ORMs every\nday will keep the documentation open because there's so much to know about them.\n\n## Phase 1: Initialize the Sequelize project\n\nBecause this project already has [sequelize-cli] installed, you can initialize\nthe project by typing `npx sequelize-cli init`. The `npx` command runs\nlocally-installed tools. That will create the project structure that Sequelize\nexpects for us to continue to use its tools.\n\n## Phase 2: Create a database user for the project\n\nUsing a PostgreSQL client like `psql` or Postbird, create a new user for this\napplication named \"sequelize_recipe_box_app\" with the password \"HfKfK79k\" _and_\nthe ability to create a database. Here's the [link to the CREATE USER\ndocumentation] so that you can determine which options to give.\n\n## Phase 2: Change the connection configuration\n\nThe project contains a directory named **config**. Inside there, you will find a\nfile named **config.json**. You need to make some configuration changes.\n\n* Change all the \"user\" and \"password\" values to the information for the user\n  that you created in Phase 2.\n* Change the \"database\" values to be \"recipe_box_development\",\n  \"recipe_box_test\", and \"recipe_box_production\".\n* Change all of the \"dialect\" values from \"mysql\" to \"postgres\".\n* Delete all of the \"operatorAliases\" entries. It's to support earlier versions\n  of the Sequelize library. Make sure to remove the comma from the preceding\n  line so that it's valid JSON.\n* Because you'll be using seed data in this project, add `\"seederStorage\":\n  \"sequelize\"` to each of the different blocks so that Sequelize CLI won't run\n  a seeder more than once causing duplicate entries in the database.\n\nThat will configure the application and the Sequelize tools to properly connect\nto your development database.\n\n## Phase 3: Create your database\n\nRather than writing SQL to do this, you will use the tools. Run\n\n```\nnpx sequelize-cli db:create\n```\n\nThat runs the Sequelize CLI with the command `db:create`.\n\nWhen you run this, it will default to the \"development\" setting and read the\ninformation from the configuration file to create your database for you! It\nshould print out something like\n\n```\nSequelize CLI [Node: 10.19.0, CLI: 5.5.1, ORM: 5.21.5]\n\nLoaded configuration file \"config/config.json\".\nUsing environment \"development\".\nDatabase recipe_box_development created.\n```\n\nYou can also drop the database by typing ... you guessed it! The Sequelize CLI\nwith the command `db:drop`!\n\n```\nnpx sequelize-cli db:drop\n```\n\nIf you run that, run the \"create\" command, again, so the database exists.\n\n## Phase 4: The units of measurement data\n\nJust as a review, here is the specification for the table that holds units of\nmeasurement.\n\n| Column Name | Column Type | Constraints |\n|-------------|-------------|-------------|\n| id          | SERIAL      | PK          |\n| name        | VARCHAR(20) | NOT NULL    |\n\nLuckily, the Sequelize models and migrations take care of the \"id\" property for\nyou without you having to do anything. So, you can just focus on that \"name\"\nproperty.\n\n### Create a migration\n\nIt's time to create the first migration, the one that defines the table that\nwill hold units of measure. You can use the Sequelize CLI to generate the\nmigration for you. You can _also_ tell it to create a model for you, and it will\ncreate a migration along _with_ the model. You should do that to get the biggest\nreturn on investment for the characters that you will type.\n\nThe command is `model:generate` and it takes a couple of arguments, \"--name\"\nwhich contains the name of the model (as a singular noun) to generate,\nand \"--attributes\" which has a comma-separated list of \"property-name:data-type\"\npairs.\n\n**Learning Tip**: It is _so very important_ that you don't copy and paste this.\nType these things out so it has a better chance of creating durable knowledge.\n\n```\nnpx sequelize-cli model:generate \\\n  --name MeasurementUnit \\\n  --attributes name:string\n```\n\nThat will create two files, if everything works well. (The name of your\nmigration file will be different because it's time-based.)\n\n```\nNew model was created at models/measurementunit.js\nNew migration was created at migrations/20200101012349-MeasurementUnit.js\n```\n\nThe **model** file will be used by the application to query the database. It\nwill be used by the express.js application. It is part of the running software.\n\nThe **migration** file is used to construct the database. It is only used by the\nSequelize CLI tool to build the database. Unlike those schema and seed files\nthat you had in the SQL version of this project which destroyed _everything_\nwhen run, migrations are designed to change your database as your application\ngrows. This is a much better strategy so that existing data in the databases\nthat other people use aren't damaged.\n\nBecause the data model requires the \"name\" column to be both non-null _and_\nunique, you have to add some information to the migration file. Open it and, for\nthe \"name\" property, make non-nullable by looking at how the other properties\nare configured. Then, add the \"unique\" property set to `true` to the \"name\"\nconfiguration, as well. That should be enough for Sequelize to create the table\nfor you.\n\nThe last thing to do is to change the length of the \"name\" property. By default,\nSequelize will make it 255 characters long. The specification for the table\nsays it should really only be 20 characters. To tell the migration that, change\nthe type for \"name\" from `Sequelize.STRING` to `Sequelize.STRING(20)`.\n\n## Run your migration\n\nIf you now run your migration with the Sequelize CLI, it will create the table\nfor you.\n\n```\nnpx sequelize-cli db:migrate\n```\n\nThat should give you some output that looks similar to this.\n\n```\nLoaded configuration file \"config/config.json\".\nUsing environment \"development\".\n== 20200101012349-create-measurement-unit: migrating =======\n== 20200101012349-create-measurement-unit: migrated (0.021s)\n```\n\nYou can confirm that the table \"MeasurementUnits\" is created by using your\nPostgreSQL client. You'll also see that another table is created,\n\"SequelizeMeta\", which contains information about which migration has most\nrecently been run. It contains a single column, \"name\". Each row contains an\nentry of which migration file has run. Now that you've run your migration file,\nthe table contains one entry, the name of your migration file. When you run\nmore migrations, you will see more rows, each containing the name of the file\nthat you've run.\n\n**psql Note**: If you are using `psql` as you PostgreSQL command, be aware that\nit will lowercase any entity and column names you type in there. If you type\n`SELECT * FROM MeasurementUnits`, it converts that to `SELECT * FROM\nmeasurementunits` before running it. To prevent that from happening, use\nquotation marks around the table name. `SELECT * FROM \"MeasurementUnits\"` will\ndo the trick.\n\nIt's important that you _never_ change the name of a migration file after it's\nbeen run.\n\nIn the real world, you should _never_ change the content of a migration file\nafter it's been committed and shared in your Git repository. Asking others to\nrollback their migrations just because you changed one of yours is bad manners.\nInstead, you should add a new migration that makes the change that you want.\n\n## Create the seed data\n\nYou can create the seed data for the unit of measurements by creating a\n**seeder** as the Sequelize CLI calls them. You can create one using the\nSequelize CLI tool. Run the following and make sure you don't get any errors.\n\n```\nnpx sequelize-cli seed:generate --name default-measurement-units\n```\n\nNow, you want to insert the seed data. You will do this by using the\n`bulkInsert` method of the object passed in through the `queryInterface`\nparameter of the `up` method. Feel free to delete the comment in the `up` method\nand replace it with this.\n\n```js\nreturn queryInterface.bulkInsert('MeasurementUnits', [\n  { name: 'cups', createdAt: new Date(), updatedAt: new Date() },\n]);\n```\n\nThe `bulkInsert` method takes two parameters:\n\n* The name of the table to insert into, and\n* An array of objects that have property names that match the column names in\n  the table.\n\nYou can see that the first object has been provided by the example. Now, create\nobjects for all of these values, as well. (The empty item in the list is an\nempty string and is intentional) Make sure you do them **in this order,** or\nwhen we get to the seed data for the other tables it won't work. (We've supplied\nyou with files for the seed data for the other tables because there is a lot of\nit)\n\n* \"fluid ounces\"\n* \"gallons\"\n* \"grams\"\n* \"liters\"\n* \"milliliters\"\n* \"ounces\"\n* \"pinch\"\n* \"pints\"\n* \"pounds\"\n* \"quarts\"\n* \"tablespoons\"\n* \"teaspoons\"\n* \"\"\n* \"cans\"\n* \"slices\"\n* \"splash\"\n\nNow, run the Sequelize CLI with the command `db:seed:all`.\n\nAfter you get that done, you can confirm that all of the records (rows) were\ncreated in the \"MeasurementUnits\" table.\n\n## Phase 5: The recipe table model\n\nThis will go much like the last one, except there's no seed data. Just to\nrefresh your memory, here's the specification for the \"recipes\" table.\n\n| Column Name | Column Type  | Constraints                         |\n|-------------|--------------|-------------------------------------|\n| id          | SERIAL       | PK                                  |\n| title       | VARCHAR(200) | NOT NULL                            |\n| created     | TIMESTAMP    | NOT NULL, DEFAULT CURRENT_TIMESTAMP |\n| updated     | TIMESTAMP    | NOT NULL, DEFAULT CURRENT_TIMESTAMP |\n\nAs you've discovered, Sequelize takes care of the \"id\" for you _and_ the columns\nto track when the recipe has been created and updated! Your job is to\n\n* Generate a model for the \"recipe\"\n* Customize the migration so the \"title\" column is not nullable\n\nRun your migration and confirm that you defined it correctly by checking the\nattributes in the description of the table. The important parts to check are\nthat the \"title\" column is a VARCHAR(200) and is non-nullable. (The \"Collation\"\ncolumn has been removed for brevity.)\n\n```\n                  Table \"public.Recipes\"\n  Column   |           Type           | Nullable |  Default\n-----------+--------------------------+----------+------------\n id        | integer                  | not null | nextval(...\n title     | character varying(200)   | not null |\n createdAt | timestamp with time zone | not null |\n updatedAt | timestamp with time zone | not null |\nIndexes:\n    \"Recipes_pkey\" PRIMARY KEY, btree (id)\n```\n\n## Phase 6: The instruction table model\n\nNow, things get a little trickier because this model will reference the recipe\nmodel. Here's the specification for the \"instructions\" table.\n\n| Column Name   | Column Type | Constraints  |\n|---------------|-------------|--------------|\n| id            | SERIAL      | PK           |\n| specification | TEXT        | NOT NULL     |\n| listOrder     | INTEGER     | NOT NULL     |\n| recipeId      | INTEGER     | FK, NOT NULL |\n\nWhen you type out your migration generation command, the \"--attributes\"\nparameter will look like this:\n\n```\n--attributes column1:type1,column2:type2,column3:type3\n```\n\nInstead of using \"string\" for the \"specification\" column of the table, use\n\"text\" to generate a TEXT column.\n\nAfter it generates the migration file, modify each of the column descriptors in\nthe migration so that the columns are not nullable. Then, add a new property\nto the one for \"recipeId\" called \"references\" that is an object that contains\na \"model\" property set to \"Recipes\". It should look like this.\n\n```js\nrecipeId: {\n  allowNull: false,\n  references: { model: \"Recipes\" },\n  type: Sequelize.INTEGER,\n},\n```\n\nWith that in place, run the migration. Then, check the table definition in your\nPostgreSQL client.\n\n```\n                   Table \"public.Instructions\"\n    Column     |           Type           | Nullable |     Default\n---------------+--------------------------+----------+-----------------\n id            | integer                  | not null | nextval('\"Ins...\n specification | text                     | not null |\n listOrder     | integer                  | not null |\n recipeId      | integer                  | not null |\n createdAt     | timestamp with time zone | not null |\n updatedAt     | timestamp with time zone | not null |\nIndexes:\n    \"Instructions_pkey\" PRIMARY KEY, btree (id)\nForeign-key constraints:\n    \"Instructions_recipeId_fkey\" FOREIGN KEY (\"recipeId\")\n                                 REFERENCES \"Recipes\"(id)\n```\n\nYou should see all non-null columns and a foreign key between the \"Instructions\"\ntable and the \"Recipes\" table.\n\n## Phase 7: The ingredients model\n\nThe model for ingredients has _two_ foreign keys. Create the model and migration\nfor it. Here's the table specification.\n\n| Column Name       | Column Type   | Constraints  |\n|-------------------|---------------|--------------|\n| id                | SERIAL        | PK           |\n| amount            | NUMERIC(5, 2) | NOT NULL     |\n| measurementUnitId | INTEGER       | FK, NOT NULL |\n| foodStuff         | VARCHAR(500)  | NOT NULL     |\n| recipeId          | INTEGER       | FK, NOT NULL |\n\nAfter you modify and run your migration, you should have a table in your\ndatabase that looks like this, with two foreign keys, one to the \"Recipes\"\ntable and the other to the \"MeasurementUnits\" table.\n\n```\n                       Table \"public.Ingredients\"\n      Column       |           Type           | Nullable |      Default\n-------------------+--------------------------+----------+-----------------\n id                | integer                  | not null | nextval('\"Ing...\n amount            | numeric(5,2)             | not null |\n measurementUnitId | integer                  | not null |\n foodStuff         | character varying(500)   | not null |\n recipeId          | integer                  | not null |\n createdAt         | timestamp with time zone | not null |\n updatedAt         | timestamp with time zone | not null |\nIndexes:\n    \"Ingredients_pkey\" PRIMARY KEY, btree (id)\nForeign-key constraints:\n    \"Ingredients_measurementUnitId_fkey\"\n        FOREIGN KEY (\"measurementUnitId\")\n        REFERENCES \"MeasurementUnits\"(id)\n    \"Ingredients_recipeId_fkey\"\n        FOREIGN KEY (\"recipeId\")\n        REFERENCES \"Recipes\"(id)\n```\n\n## Phase 8: Seed data for all of the tables\n\nNow that you have tables in the database, it's time to create some seed data for\nall of them. In the **data-access-layer** directory, you will find three text\nfiles each containing JavaScript objects on each row that match the tables\nin the previous three sections.\n\nIf you didn't seed the MeasurementUnits data in the correct order listed in the\nsection above, you may have to redo that seed file, because the data from the\ntext files depends on the ids of the data in the `MeasurementUnits` table being\ncorrect.\n\nThere are three tables to seed: Ingredients, Instructions, and Recipes. It is\nimportant to note that you will need to seed them in the correct order due to\nforeign key dependencies.\n\nLook at the data model for the application, again.\n\n![recipe box data model]\n\nYou can see that the Instructions depends on Recipes because it has the foreign\nkey \"recipeId\" to the Recipes table. You can also see that the Ingredients table\nhas dependencies on the Recipes and MeasurementUnits tables because of its\nforeign keys \"measurementUnitId\" and \"recipeId\". (You've already seeded the\nMeasurementUnits table in Phase 4, so that data exists for use by the\nIngredients table.) Recipes does not have any foreign keys. You need to seed\nRecipes, first, because it does not have any foreign keys and, therefore, does\nnot have any data dependencies. Then, you can seed the Instructions and\nIngredients tables in either order because their data dependencies will have\nbeen met.\n\nCreate seeder files for them in that order: Recipes, first, then Ingredients and\nInstructions. Use the contents of each of the text files in\n**data-access-layer** to do bulk inserts.\n\nAfter you create each seed file, run\n\n```\nnpx sequelize-cli db:seed:all\n```\n\nto make sure you don't have any errors. If you do, fix them before moving onto\nthe next seed file.\n\nIf you end up seeding the data in the wrong order and getting a foreign key\nconstraint error, just use the CLI to drop the database, create the database,\nmigrate the database, and then you can try running your seeders, again. You may\nneed to rename your migration filenames to get your seeds running in the\ncorrect order.\n\n## Phase 9: Updating models with references\n\nNow that you have all of the migrations set up correctly and a database defined,\nit is time for you to turn your attention to the model files that were\ngenerated in the previous phases.\n\nConsider the relationship between an Instruction and a Recipe. A Recipe _has\nmany_ Instructions. In the other direction, you would say that an Instruction\n_has one_ Recipe, or that Instruction _belongs to_ the Recipe. To set that up in\nyour model, open the file **models/recipe.js**. In there, you will see the\nfollowing.\n\n```js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Recipe = sequelize.define('Recipe', {\n    title: DataTypes.STRING\n  }, {});\n  Recipe.associate = function(models) {\n    // associations can be defined here\n  };\n  return Recipe;\n};\n```\n\nIn the `associate` function is where you can define the association between the\nRecipe and the Instruction. Replace the comment with the following statement.\n\n```js\nRecipe.hasMany(models.Instruction, { foreignKey: 'recipeId' });\n```\n\nThis instructs Sequelize that Recipe should have a collection of Instruction\nobjects associated with it. To insure that Sequelize uses the foreign key column\nthat you created on the \"Instructions\" table in your migration, you must specify\nit as part of the collection definition.\n\nIn the file **models/instruction.js**, replace the comment with the following to\ndefine the other side of the relationship.\n\n```js\nInstruction.belongsTo(models.Recipe, { foreignKey: 'recipeId' });\n```\n\nThis instructs Sequelize that Instruction has a single Recipe object associated\nwith it. Again, because of inconsistent naming conventions used by Sequelize,\nyou must specify the foreign key column name in the \"Instructions\" table.\n\nThink about the many-to-one and one-to-many relationships between Ingredient,\nMeasurementUnit, and Recipe. Then, modify those model files accordingly with\nthe `hasMany` and `belongsTo` associations, always specifying the name of the\nforeign key column that binds the two tables together.\n\n## Phase 10: Updating models with validations\n\nNow that you have seed data created, it will be important to prevent users from\nentering data that does not meet the expectations of the data model.\n\nConsider the content of **models/instruction.js**\n\n```js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Instruction = sequelize.define('Instruction', {\n    specification: DataTypes.TEXT,\n    listOrder: DataTypes.INTEGER,\n    recipeId: DataTypes.INTEGER\n  }, {});\n  Instruction.associate = function(models) {\n    Instruction.belongsTo(models.Recipe, { foreignKey: 'recipeId' });\n  };\n  return Instruction;\n};\n```\n\nIt would be nice if the model could validate each of those properties to make\nsure that no one sets them to null and that `listOrder` is greater than 0, for\nexample. You can do that with [per-attribute validations].\n\nFor example, you can change the above code to the following to make sure that\nthe \"specification\" property won't get set to an empty string when someone tries\nto save the object.\n\n```js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Instruction = sequelize.define('Instruction', {\n    specification: {\n      type: DataTypes.TEXT,\n      validate: {\n        notEmpty: true,\n      },\n    },\n    listOrder: DataTypes.INTEGER,\n    recipeId: DataTypes.INTEGER\n  }, {});\n  Instruction.associate = function(models) {\n    Instruction.belongsTo(models.Recipe, { foreignKey: 'recipeId' });\n  };\n  return Instruction;\n};\n```\n\nMake sure all of the other string properties in the models won't allow the empty\nstring to be set on them.\n\n## Phase 11: Cascade delete for recipes\n\nThe Recipe model has dependencies: the Instruction and the Ingredient both have\n_belongs to_ relationships. This means that the row in the \"Recipes\" table must\nexist to have records in the \"Ingredients\" and \"Instructions\" table. If you try\nto delete a Recipe row from the database that has either Instructions or\nIngredients, it won't work due to referential integrity. You would have to\ndelete all of the Ingredients and Instructions _before_ being able to delete the\nRecipe.\n\nSequelize provides a handy shortcut for that and will manage deleting the\nassociated records for you when you delete a row from the Recipes table. It's\ncalled a _cascading delete_. Open the **models/recipe.js** file. In there,\nmodify the second argument of each of the `hasMany` calls to include two new\nproperty/value pairs:\n\n* `onDelete: 'CASCADE'`\n* `hooks: true`\n\nRefer to the documentation on [Associations] to see an example. But, don't\ndelete the `foreignKey` property that you put there in Phase 9.\n\n## Phase 12: Building the repositories\n\nNow that you have the seeds, models, and migrations out of the way, you can\nbuild the data access layer with a lot of speed. Sequelize will now handle all\nof the SQL generation for you. You can just use the models that you've\npainstakingly crafted.\n\nBecause you are writing JavaScript files, you want the server to restart because\nit won't automatically reload the changed JavaScript that you're writing. To\nthat end, you will use a different command while developing.\n\n```\nnpm run dev\n```\n\nThis runs a special script that will reload the JavaScript in the data access\nlayer every time you make a change. You can see what's run in the\n**package.json** file in this project in the \"scripts\" section for the \"dev\"\nproperty.\n\nYou will work in the three files named\n\n* **recipes-repository.js**: The collection of functions needed to interact with\n  recipes for the application\n* **instructions-repository.js**: The collection of functions needed to interact\n  with the instructions for the application\n* **ingredients-repository.js**: The collection of functions needed to interact\n  with the ingredients for the application\n\nEach of the files imports your models and makes them available to you. Then,\nyou can use them in your querying. Follow the hints in each of the repository\nfunctions.\n\n\n\n[Recipe card]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/sql-recipe-card.jpeg\n[express.js]: https://www.expressjs.com\n[pug]: https://pugjs.org\n[node-postgres]: https://node-postgres.com\n[Parameterized query]: https://node-postgres.com/features/queries#Parameterized%20query\n[Sequelize documentation]: https://sequelize.org/v5/\n[sequelize]: https://www.npmjs.com/package/sequelize\n[sequelize-cli]: https://www.npmjs.com/package/sequelize-cli\n[link to the CREATE USER documentation]: https://www.postgresql.org/docs/current/sql-createuser.html\n[per-attribute validations]: https://sequelize.org/master/manual/validations-and-constraints.html#per-attribute-validations\n[Associations]: https://sequelize.org/master/manual/hooks.html#associations\n[recipe box data model]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/sql-recipe-box-data-model.png\n"
  },
  "success": true
}