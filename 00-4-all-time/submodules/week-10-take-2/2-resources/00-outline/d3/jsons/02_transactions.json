{
  "template": {
    "taskId": "9a8a6db9-eeb4-4762-8990-a8ee8e05aa6c",
    "name": "Transactions",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/sql/readings/reading-12-transactions-sql.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "transactions"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Using SQL Transactions\n\nTransactions allow us to make changes to a SQL database in a consistent and\ndurable way, and it’s a best practice to use them regularly.\n\nIn this reading, we’ll cover what a transaction is and why we want to use it, as\nwell as how to write explicit transactions.\n\n## What is a transaction?\n\nA transaction is a single unit of work, which can contain multiple operations,\nperformed on a database. According to the [PostgreSQL docs][1], the important\nthing to note about a transaction is that “it bundles multiple steps into a\nsingle, all-or-nothing operation”. If any operation within the transaction\nfails, then the entire transaction fails. If all the operations succeed, then\nthe entire transaction succeeds.\n\n## Implicit vs. explicit transactions\n\nEvery SQL statement is effectively a transaction. When you insert a new table\nrow into a database table, for example, you are creating a transaction. The\nfollowing `INSERT` statement is a transaction:\n\n```sql\nINSERT INTO hobbits(name,purpose)\n  VALUES('Frodo','Destroy the One Ring of power.');\n```\n\nThe above code is known as an  _implicit_ transaction. With an implicit\ntransaction, changes to the database happen immediately, and we have no way to\nundo or roll back these changes. We can only make subsequent changes/\ntransactions.\n\nAn _explicit_ transaction, however, allows us to create save points and roll\nback to whatever point in time we choose. An explicit transaction begins with\nthe command `BEGIN`, followed by the SQL statement, and then ends with either a\n`COMMIT` or `ROLLBACK`.\n\n### PostgreSQL transactional commands\n\n**[BEGIN][3]**\n-- Initiates a transaction block. All statements after a BEGIN command will be\nexecuted in a single transaction until an explicit COMMIT or ROLLBACK is given.\n\nStarting a transaction:\n\n```sql\nBEGIN;\n  INSERT INTO hobbits(name,purpose)\n    VALUES('Frodo','Destroy the One Ring of power.');\n```\n\n**[COMMIT][4]**\n -- Commits the current transaction. All changes made by the transaction become\n visible to others and are guaranteed to be durable if a crash occurs.\n\nCommitting a transaction:\n\n```sql\nBEGIN;\n  INSERT INTO hobbits(name,purpose)\n    VALUES('Frodo','Destroy the One Ring of power.');\nCOMMIT;\n```\n\n**[ROLLBACK][5]**\n-- Rolls back the current transaction and causes all the updates made by the\ntransaction to be discarded. Can only undo transactions since the last COMMIT or\nROLLBACK command was issued.\n\nRolling back a transaction (i.e. abort all changes):\n\n```sql\nBEGIN;\n  INSERT INTO hobbits(name,purpose)\n    VALUES('Frodo','Destroy the One Ring of power.');\nROLLBACK;\n```\n\n**[SAVEPOINT][6]**\n-- Establishes a new save point within the current transaction. Allows all\ncommands executed after the save point to be rolled back, restoring the\ntransaction state to what it was at the time of the save point.\n\nSyntax to create save point: `SAVEPOINT savepoint_name;`\nSyntax to delete a save point: `RELEASE SAVEPOINT savepoint_name;`\n\nLet’s say we had the following table called `fellowship`:\n\n| name | age |\n|---|---|\n| Frodo | 50 |\n| Samwise | 38 |\n| Merry | 36 |\n| Pippin | 28 |\n| Aragorn | 87 |\n| Boromir | 40 |\n| Legolas | 2000 |\n| Gandalf | 2000 |\n\nWe'll create a transaction on this table containing a few operations. Inside\nthe transaction, we’ll establish a save point that we’ll roll back to before\ncommitting.\n\n```sql\nBEGIN;\n  DELETE FROM fellowship\n    WHERE age > 100;\n  SAVEPOINT first_savepoint;\n  DELETE FROM fellowship\n    WHERE age > 80;\n  DELETE FROM fellowship\n    WHERE age >= 40;\n  ROLLBACK TO first_savepoint;\nCOMMIT;\n```\n\nOnce our transaction is committed, our table would look like this:\n\n| name | age |\n|---|---|\n| Frodo | 50 |\n| Samwise | 38 |\n| Merry | 36 |\n| Pippin | 28 |\n| Aragorn | 87 |\n| Boromir | 40 |\n\nWe can see that the deletion that happened just prior to the savepoint creation\nwas preserved.\n\n**[SET TRANSACTION][7]**\n  -- Sets the characteristics of the current transaction. (_Note: To set\n  characteristics for subsequent transactions in a session, use `SET SESSION\n  CHARACTERISTICS`.) The available transaction characteristics are the\n  transaction isolation level, the transaction access mode (read/write or\n  read-only), and the deferrable mode. (_Read more about these characteristics\n  in the [PostgreSQL docs][7]._)\n\nExample of setting transaction characteristics:\n\n```sql\nBEGIN;\n  SET TRANSACTION READ ONLY;\n  ...\nCOMMIT;\n```\n\n## When to use transactions and why\n\nIt is generally a good idea to use explicit SQL transactions when making any\nupdates, insertions, or deletions, to a database. However, you generally\nwouldn’t write an explicit transaction for a simple `SELECT` query.\n\nTransactions help you deal with crashes, failures, data consistency, and error\nhandling. The ability to create savepoints and roll back to earlier points is\ntremendously helpful when doing multiple updates and helps maintain data\nintegrity.\n\nAnother benefit of transactions is the _**atomic**_, or “all-or-nothing”, nature\nof their operations. Because all of the operations in a transaction must succeed\nor else be aborted, partial or incomplete updates to the database will not be\nmade. End-users will see only the final result of the transaction.\n\n## Transaction properties: ACID\n\nA SQL transaction has four properties known collectively as “ACID” -- which is an acronym for _Atomic, Consistent, Isolated, and Durable_. The following descriptions come from the IBM doc “[ACID properties of transactions][2]”:\n\n**Atomicity**\n-- All changes to data are performed as if they are a single operation. That is, all the changes are performed, or none of them are.\n\nFor example, in an application that transfers funds from one account to another,\nthe atomicity property ensures that, if a debit is made successfully from one\naccount, the corresponding credit is made to the other account.\n\n**Consistency**\n-- Data is in a consistent state when a transaction starts and when it ends.\n\nFor example, in an application that transfers funds from one account to another,\nthe consistency property ensures that the total value of funds in both the\naccounts is the same at the start and end of each transaction.\n\n**Isolation**\n-- The intermediate state of a transaction is invisible to other transactions.\nAs a result, transactions that run concurrently appear to be serialized.\n\nFor example, in an application that transfers funds from one account to another,\nthe isolation property ensures that another transaction sees the transferred\nfunds in one account or the other, but not in both, nor in neither.\n\n**Durability**\n-- After a transaction successfully completes, changes to data persist and are\nnot undone, even in the event of a system failure.\n\nFor example, in an application that transfers funds from one account to another,\nthe durability property ensures that the changes made to each account will not\nbe reversed.\n\n### Banking transaction example\n\nLet’s look at an example from the [PostgreSQL Transactions doc][1] that\ndemonstrates the ACID properties of a transaction. We have a bank database that\ncontains customer account balances, as well as total deposit balances for\nbranches. We want to record a payment of $100.00 from Alice's account to Bob's\naccount, as well as update the total branch balances. The transaction would\nlook like the code below.\n\n```sql\nBEGIN;\n  UPDATE accounts SET balance = balance - 100.00\n      WHERE name = 'Alice';\n  UPDATE branches SET balance = balance - 100.00\n      WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');\n  UPDATE accounts SET balance = balance + 100.00\n      WHERE name = 'Bob';\n  UPDATE branches SET balance = balance + 100.00\n      WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');\nCOMMIT;\n```\n\nThere are several updates happening above. The bank wants to make sure that all\nof the updates happen or none happen, in order to ensure that funds are\ntransferred from the proper account (i.e. Alice’s account) to the proper\nrecipient’s account (i.e. Bob’s account). If any of the updates fails, none of\nthem will take effect. That is, if something goes wrong either with withdrawing\nfunds from Alice’s account or transferring the funds into Bob’s account, then\nthe entire transaction will be aborted and no changes will occur. This prevents\nAlice or Bob from seeing a transaction in their account summaries that isn’t\nsupposed to be there.\n\nThere are many other scenarios where we would want to use an atomic operation to\nensure a successful end result. Transactions are ideal for such scenarios, and\nwe should use them whenever they’re applicable.\n\n## Helpful links:\n\n* [PostgreSQL: Transactions][1]\n* [PostgreSQL Tutorial: PostgreSQL Transaction][8]\n* [PostgreSQL: BEGIN][3]\n* [PostgreSQL: COMMIT][4]\n* [PostgreSQL: ROLLBACK][5]\n* [PostgreSQL: SAVEPOINT][6]\n* [PostgreSQL: SET TRANSACTION][6]\n\n[1]: https://www.postgresql.org/docs/8.3/tutorial-transactions.html\n[2]: https://www.ibm.com/support/knowledgecenter/en/SSGMCP_5.4.0/product-overview/acid.html\n[3]: https://www.postgresql.org/docs/9.1/sql-begin.html\n[4]: https://www.postgresql.org/docs/9.1/sql-commit.html\n[5]: https://www.postgresql.org/docs/9.1/sql-rollback.html\n[6]: https://www.postgresql.org/docs/9.1/sql-savepoint.html\n[7]: https://www.postgresql.org/docs/9.1/sql-set-transaction.html\n[8]: http://www.postgresqltutorial.com/postgresql-transaction/"
  },
  "success": true
}