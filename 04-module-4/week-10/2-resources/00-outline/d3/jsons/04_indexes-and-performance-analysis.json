{
  "template": {
    "taskId": "1438d00e-93d6-4d67-8d78-26bd8905884d",
    "name": "Indexes and Performance Analysis",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/sql/readings/reading-15-indexes-sql.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "indexes-and-performance-analysis"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# PostgreSQL Indexes\n\nPostgreSQL indexes can help us optimize our queries for faster performance. In\nthis reading, we'll learn how to create an index, when to use an index, and when\nto avoid using them.\n\n## What is a PostgreSQL index?\n\nA PostgreSQL index works like an index in the back of a book. It points to\ninformation contained elsewhere and can be a faster method of looking up the\ninformation we want.\n\nA book index contains a list of references with page numbers. Instead of having\nto scan all the pages of the book to find the places where specific information\nappears, a reader can simply check the index. In similar fashion, PostgreSQL\nindexes, which are special lookup tables, let us make faster database queries.\n\nLetâ€™s say we had the following table:\n\n| addresses    |\n|--------------|\n| address_id   |\n| address      |\n| address2     |\n| city_id      |\n| postal_code  |\n| phone_number |\n\nAnd we made a query to the database like the following:\n\n```sql\nSELECT * FROM addresses WHERE phone_number = '5556667777';\n```\n\nThe above query would scan every row of the \"addresses\" table to find matching\nrows based on the given phone number. If \"addresses\" is a large table (let's say\nwith millions of entries), and we only expect to get a small number of results\nback (one row, or a few rows), then such a query would be an inefficient way to\nretrieve data. Instead of scanning every row, we could create an index for the\nphone column for faster data retrieval.\n\n## How to create an index\n\nTo create a [PostgreSQL index][1], use the following syntax:\n\n```sql\nCREATE INDEX index_name ON table_name (column_name);\n```\n\nWe can create a phone number index for the above \"addresses\" table with the\nfollowing:\n\n```sql\nCREATE INDEX addresses_phone_index ON addresses (phone_number);\n```\n\nYou can delete an index using the `DROP INDEX` command:\n\n```sql\nDROP INDEX addresses_phone_index;\n```\n\nAfter an index has been created, the system will take care of the rest -- it\nwill update an index when the table is modified and use the index in queries\nwhen it improves performance over a full table scan.\n\n### Types of indexes\n\nPostgreSQL provides several index types: B-tree, Hash, GiST and GIN. The CREATE\nINDEX command creates B-tree indexes by default, which fit the most common\nsituations. While it's good to know other index types exist, you'll probably\nfind yourself using the default B-tree most often.\n\n**Single-Column Indexes**\nUses only one table column.\n\nSyntax:\n```sql\nCREATE INDEX index_name ON table_name (column_name);\n```\n\nAddresses Example:\n```sql\nCREATE INDEX addresses_phone_index ON addresses (phone_number);\n```\n\n**Multiple-Column Indexes**\nUses more than one table column.\n\nSyntax:\n```sql\nCREATE INDEX index_name ON table_name (col1_name, col2_name);\n```\n\nAddresses Example:\n```sql\nCREATE INDEX idx_addresses_city_post_code ON table_name (city_id, postal_code);\n```\n\n**Partial Indexes**\nUses subset of a table defined by a conditional expression.\n\nSyntax:\n```sql\nCREATE INDEX index_name ON table_name WHERE (conditional_expression);\n```\n\nAddresses Example:\n```sql\nCREATE INDEX addresses_phone_index ON addresses (phone_number) WHERE (city_id = 2);\n```\n\n**Note**: Check out [Chapter 11 on Indexes][3] in the PostgreSQL docs for more\nabout types of indexes.\n\n## When to use an index\n\nIndexes are intended to enhance database performance and are generally thought\nto be a faster data retrieval method than a sequential (or row-by-row) table\nscan. However, there are instances where using an index would not improve\nefficiency, such as the following:\n\n* When working with a relatively small table (i.e. not a lot of rows)\n* When a table has frequent, large-batch update or insert operations\n* When working with columns that contain many NULL values\n* When working with columns that are frequently manipulated\n\nAn important thing to note about indexes is that, while they can optimize READ\n(i.e. table query) speed, they can also hamper WRITE (i.e. table\nupdates/insertions) speed. The latter's performance is affected due to the\nsystem having to spend time updating indexes whenever a change or insertion is\nmade to the table.\n\nThe system optimizes database performance and decides whether to use an\nindex in a query or to perform a sequential table scan, but we can analyze query\nperformance ourselves to debug slow queries using `EXPLAIN` and `EXPLAIN ANALYZE`.\n\nHere is an example of using `EXPLAIN` from the [PostgreSQL docs][2]:\n\n```sql\nEXPLAIN SELECT * FROM tenk1;\n\n                         QUERY PLAN\n-------------------------------------------------------------\n Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)\n```\n\nIn the QUERY PLAN above, we can see that a sequential table scan (`Seq Scan`)\nwas performed on the table called \"tenk1\". In parentheses, we see performance\ninformation:\n\n* Estimated start-up cost (or time expended before the scan can start): 0.00\n* Estimated total cost: 458.00\n* Estimated number of rows output: 10000\n* Estimated average width (in bytes) of rows: 244\n\nIt's important to note that, although we might mistake the number next to `cost`\nfor milliseconds, `cost` is not measured in any particular unit and is\nan arbitrary measurement relatively based on other query costs.\n\nIf we use the `ANALYZE` keyword after `EXPLAIN` on a `SELECT` statement, we can\nget more information about query performance:\n\n```sql\nEXPLAIN ANALYZE SELECT *\nFROM tenk1 t1, tenk2 t2\nWHERE t1.unique1 < 100 AND t1.unique2 = t2.unique2;\n\n                                                            QUERY PLAN\n----------------------------------------------------------------------------------------------------------------------------------\n Nested Loop  (cost=2.37..553.11 rows=106 width=488) (actual time=1.392..12.700 rows=100 loops=1)\n   ->  Bitmap Heap Scan on tenk1 t1  (cost=2.37..232.35 rows=106 width=244) (actual time=0.878..2.367 rows=100 loops=1)\n         Recheck Cond: (unique1 < 100)\n         ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..2.37 rows=106 width=0) (actual time=0.546..0.546 rows=100 loops=1)\n               Index Cond: (unique1 < 100)\n   ->  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..3.01 rows=1 width=244) (actual time=0.067..0.078 rows=1 loops=100)\n         Index Cond: (unique2 = t1.unique2)\n Total runtime: 14.452 ms\n ```\n\nWe can see in the QUERY PLAN above that there are other types of scans\nhappening: Bitmap Heap Scan, Bitmap Index Scan, and Index Scan. We know that an\nindex has been created, and the system is using it to scan for results instead\nof performing a sequential scan. At the bottom, we also have a total runtime of\n14.42 ms, which is pretty fast.\n\n## Helpful links:\n\n* [PostgreSQL docs: Indexes][3]\n* [PostgreSQL docs: Performance Tips][4]\n* [Heroku DevCenter: Efficient Use of PostgreSQL Indexes][5]\n\n## What we learned:\n\n* How to create a PostgreSQL index\n* Types of indexes\n* Use cases for indexes and when to avoid them\n* How to use `EXPLAIN` to analyze query performance\n\n[1]: https://www.postgresql.org/docs/9.1/sql-createindex.html\n[2]: https://www.postgresql.org/docs/9.1/using-explain.html\n[3]: https://www.postgresql.org/docs/9.1/indexes.html\n[4]: https://www.postgresql.org/docs/8.1/performance-tips.html\n[5]: https://devcenter.heroku.com/articles/postgresql-indexes\n"
  },
  "success": true
}