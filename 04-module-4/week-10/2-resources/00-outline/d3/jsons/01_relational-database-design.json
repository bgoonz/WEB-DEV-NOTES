{
  "template": {
    "taskId": "12cc0ea0-8165-455b-bf59-742d700d53c4",
    "name": "Relational Database Design",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/sql/readings/reading-11-creating-schema-rdd-sql.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "relational-database-design"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Creating A Schema For Relational Database Design\n\nSchemas allow use to easily visualize database tables and their relationships to\none another, so that we can identify areas that need clarity, refinement, or\nredesign.\n\nIn this reading, we’re going to cover the stages of relational database design\nand how to create schema that depicts database table relationships.\n\n## What is Relational Database Design?\n\nAccording to Technopedia, [Relational Database Design][1] (or RDD) differs from\nother databases in terms of data organization and transactions: “In an RDD, the\ndata are organized into tables and all types of data access are carried out via\ncontrolled transactions.”\n\nIn previous readings, we created relational database tables and accessed data\nfrom these tables through PostgreSQL queries. These tables (a.k.a. _entities_)\ncontain rows (a.k.a. _records_) and columns (a.k.a. _fields_). We also learned\nhow to uniquely identify table records by adding a `PRIMARY KEY` and how to\ncreate a table association by adding a `FOREIGN KEY`.\n\nA relational database usually contains multiple tables. It’s useful to create\nschema to help us visualize these tables, keep track of primary keys and foreign\nkeys, and create relationships among tables. This is a key part of the RDD\nprocess defined below.\n\n## Stages of Relational Database Design\n\nThere are four generally-agreed-upon stages of Relational Database Design:\n\n1. Define the purpose/entities of the relational DB.\n2. Identify primary keys.\n3. Establish table relationships.\n4. Apply normalization rules.\n\n### 1. Define database purpose and entities\n\nThe first stage is identifying the purpose of the database (_Why is the database\nbeing created? What problem is it solving? What is the data used for?_), as well\nas identifying the main entities, or _tables_, that need to be created. It also\ntypically involves identifying the table’s attributes (i.e. _columns_ and\n_rows_).\n\nFor example, if we were creating a database for order processing on an\ne-commerce application, we would need a database with at least three tables: a\n`products` table, an `orders` tables, and a `users` (i.e. customers) table. We\nknow that a product will probably have an ID, name, and price, and an order will\ncontain one or more product IDs. We also know that users can create multiple\norders.\n\n![Orders ERD entities]\n\n### 2. Identify primary keys\n\nThe second stage is to identify the primary key (_PK_) of each table. As we\npreviously learned, a table’s primary key contains a unique value, or values,\nthat identify each distinct record. For our above example of online orders, we\nwould probably create IDs to serve as the primary key for each table: a product\nID, an order ID, and a user ID.\n\n![orders-erd-primary-keys.svg]\n\n### 3. Establish table relationships\n\nThe third stage is to establish the relationships among the tables in the\ndatabase. There are three types of relational database table relationships:\n\n- One-to-one\n- One-to-many\n- Many-to-many\n\n**One-to-one relationship**\n\nIn a one-to-one relationship, one record in a table is associated with only one\nrecord in another table. We could say that only one record in Table B belongs to\nonly one record in Table A.\n\nA one-to-one relationship is the least common type of table relationship. While\nthe two tables above could be combined into a single table, we may want to keep\nsome less-used data separate from the main `products` table.\n\n![products-erd-one-to-one.svg]\n\nThe above schema depicts two tables: a “products” table and a “product_details”\ntable. A `product_details` record belongs to only one product record. We've used\nan arrow to indicate the one-to-one relationship between the tables. Both tables\nhave the same primary key -- `product_id` -- which we can use in a [`JOIN`][2]\noperation to get data from both tables.\n\nThis table relationship would produce the following example data (note that not\nall columns are shown below):\n\n**Products**\n\n| id   | name                |\n| ---- | ------------------- |\n| 1597 | Glass Coffee Mug    |\n| 1598 | Metallic Coffee Mug |\n| 1599 | Smart Coffee Mug    |\n\n**Product Details**\n\n| id  | product_id | full_description                                                                                                                                                                                         |\n| --- | ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 1   | 1597       | Sturdy tempered glass coffee mug with natural cork band and silicone lid. Barista standard - fits under commercial coffee machine heads and most cup-holders.                                            |\n| 2   | 1598       | Fun coffee mug that comes in various metallic colors. Sleek, stylish, and easy to wash. Makes a great addition to your kitchen. Take it on the go by attaching the secure lid.                           |\n| 3   | 1599       | This smart mug goes beyond being a simple coffee receptacle. Its smart features let you set and maintain an exact drinking temperature for up to 1.5 hours, so your coffee is never too hot or too cold. |\n\nTake a moment to analyze the data above. Using the foreign keys, you should be\nable to reason out that the \"Metallic Coffee Mug\" is a \"Fun coffee mug that\ncomes in various metallic colors.\"\n\n**One-to-many relationship**\n\nIn a one-to-many relationship, each record in Table A is associated with\nmultiple records in Table B. Each record in Table B is associated with only one\nrecord in Table A.\n\n![orders-erd-one-to-many.svg]\n\nThe above schema depicts a one-to-many relationship between the “users” table\nand the `orders` table: One user can create multiple orders. The primary key of\nthe “orders” table (`id`) is a foreign key in the “users” table (`order_id`). We\ncan use this foreign key in a `JOIN` operation to get data from both tables.\n\nThis table relationship would produce the following example data (note that not\nall columns are shown below):\n\n**Users**\n\n| id  | name  |\n| --- | ----- |\n| 1   | Alice |\n| 2   | Bob   |\n\n**Orders**\n\n| id  | purchaser_id |\n| --- | ------------ |\n| 10  | 1            |\n| 11  | 1            |\n| 12  | 2            |\n\nTake a moment to analyze the data above. Using the foreign keys, you should be\nable to reason out that \"Alice\" has made two orders and \"Bob\" has made one\norder.\n\n**Many-to-many relationship**\n\nIn a many-to-many relationship, multiple records in Table A are associated with\nmultiple records in Table B. You would normally create a third table for this\nrelationship called a _**join table**_, which contains the primary keys from\nboth tables.\n\n![orders-erd-many-to-many.svg]\n\nThe above schema depicts a many-to-many relationship between the `products`\ntable and the `orders` table. A single order can have multiple products, and a\nsingle product can belong to multiple orders. We created a third join table\ncalled `order_details`, which contains both the`order_id` and `product_id`\nfields as foreign keys.\n\nThis table relationship would produce the following example data(note that not\nall columns are shown below):\n\n**Products**\n\n| id   | name                |\n| ---- | ------------------- |\n| 1597 | Glass Coffee Mug    |\n| 1598 | Metallic Coffee Mug |\n| 1599 | Smart Coffee Mug    |\n\n**Users**\n\n| id  | name  |\n| --- | ----- |\n| 1   | Alice |\n| 2   | Bob   |\n\n**Orders**\n\n| id  | purchaser_id |\n| --- | ------------ |\n| 10  | 1            |\n| 11  | 1            |\n| 12  | 2            |\n\n**Order Details**\n\n| id  | order_id | product_id |\n| --- | -------- | ---------- |\n| 1   | 10       | 1599       |\n| 2   | 11       | 1597       |\n| 3   | 11       | 1598       |\n| 4   | 12       | 1597       |\n| 5   | 12       | 1598       |\n| 6   | 12       | 1599       |\n\nTake a moment to analyze the data above. Using the foreign keys, you should be\nable to reason out that \"Alice\" has two orders. One order containing a \"Smart\nCoffee Mug\" and another order containing both a \"Glass Coffee Mug\" and \"Metallic\nCoffee Mug\".\n\n### 4. Apply normalization rules\n\nThe fourth stage in RDD is _**normalization**_. Normalization is the process of\noptimizing the database structure so that redundancy and confusion are\neliminated.\n\nThe rules of normalization are called “normal forms” and are as follows:\n\n1. First normal form\n2. Second normal form\n3. Third normal form\n4. Boyce-Codd normal form\n5. Fifth normal form\n\nThe first three forms are widely used in practice, while the fourth and fifth\nare less often used.\n\n**First normal form rules:**\n\n- Eliminate repeating groups in individual tables.\n- Create a separate table for each set of related data.\n- Identify each set of related data with a primary key.\n\n**Second normal form rules:**\n\n- Create separate tables for sets of values that apply to multiple records.\n- Relate these tables with a foreign key.\n\n**Third normal form rules:**\n\n- Eliminate fields that do not depend on the table’s key.\n\n_Note: For examples of how to apply these forms, read [“Description of the\ndatabase normalization basics”][3] from Microsoft._\n\n## Schema design tools\n\nMany people draw their relational database design schema with good ol’ pen and\npaper, or on a whiteboard. However, there are also lots of online tools created\nfor this purpose if you’d like to use something easily exportable/shareable.\nFeel free to check out the ERD (short for “Entity Relationship Diagram”) tools\nbelow.\n\nFree Database Diagram (ERD) Design Tools:\n\n- [Lucidchart][4]\n- [draw.io][5]\n- [dbdiagram.io][6]\n- [QuickDBD][7]\n\n## What we learned:\n\n- Stages of Relational Database Design (RDD)\n- Examples of schema depicting table relationships\n- Normalization rules\n- Schema drawing tools\n\n[1]: https://www.techopedia.com/definition/25113/relational-database-design-rdd\n[2]: https://www.postgresql.org/docs/8.3/tutorial-join.html\n[3]:\n  https://support.microsoft.com/en-us/help/283878/description-of-the-database-normalization-basics\n[4]: https://www.lucidchart.com/\n[5]: https://www.draw.io/\n[6]: https://dbdiagram.io/home?utm_source=holistics&utm_medium=top_5_tools_blog\n[7]: https://www.quickdatabasediagrams.com/\n\n[Orders ERD entities]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/orders-erd-entities.svg\n[orders-erd-primary-keys.svg]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/orders-erd-primary-keys.svg\n[products-erd-one-to-one.svg]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/products-erd-one-to-one.svg\n[orders-erd-one-to-many.svg]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/orders-erd-one-to-many.svg\n[orders-erd-many-to-many.svg]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/orders-erd-many-to-many.svg\n"
  },
  "success": true
}