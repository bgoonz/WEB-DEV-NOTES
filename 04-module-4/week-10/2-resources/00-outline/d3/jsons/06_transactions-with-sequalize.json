{
  "template": {
    "taskId": "74972c07-11c1-453f-b089-248591254d28",
    "name": "Transactions With Sequelize",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/orm/readings/reading-06-transactions-orm-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "transactions-with-sequelize"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Transactions With Sequelize\n\nIn this reading, we will learn about database _transactions_ and how we\nuse them via Sequelize. We will learn how to group multiple update\noperations into a single atomic, indivisible unit.\n\nAt the end of the reading, you should know:\n\n1. How to write code that is resilient to SQL operation failures,\n1. How to group multiple operations into a database transaction using\n   Sequelize (the `sequelize.transaction` method),\n1. How to prevent \"race conditions\" using transactions.\n\n## The Problem: Database Updates Can Fail\n\nImagine a scenario with a banking database. Markov wants to transfer\n$7,500 to Curie. To perform the transfer, we will perform two database\nupdate operations:\n\n1. Reduce Markov's account balance by $7,500,\n2. Increase Curie's account balance by $7,500.\n\nWhen transferring money, it's very important that *both* operations be\nperformed. If we reduce Markov's balance but fail to increase Curie's\nbalance, the bank effectively steals money from Markov. If we increase\nCurie's balance without reducing Markov's balance, the bank effectively\ngives away free money to Curie. Neither is acceptable.\n\nWe must keep in mind that any attempt to perform a database update can\nsometimes _fail_. It can fail for a number of reasons:\n\n1. The command is sent, but the database has previously been shut down\n   by the database administrator. Because the database is not running,\n   the database is not listening for our update, won't receive it, and\n   thus won't process it.\n2. A bug in the database or operating system software has caused the\n   database or operating system to crash. Again, the database is not\n   running, so it can neither receive nor process our update.\n3. Power has been lost to the machine running the database. The database\n   is not running.\n4. The internet connection that connects us to the database machine is\n   disrupted. The database may be running and listening for SQL requests\n   to process. However, our update request cannot get through to the\n   database machine. Because the database cannot receive our request,\n   the database cannot process it.\n5. The update asks the database to violate a pre-defined constraint. For\n   example: the database may have a constraint that an account balance\n   must never be less than zero. Any update that asks the database to\n   reduce an account balance to less than zero will be rejected and\n   therefore fail.\n\nOnly this last scenario is \"our fault.\" The fact is that database\nupdates can fail **through no fault of our own**. With regard to our\nexample: our first SQL request to reduce Markov's account balance may\nsucceed, but the database may then crash before we have sent the request\nto increase Curie's balance. Through no fault of our own, the bank has\nstolen money from Markov without giving it to Curie.\n\nHow can we write code that avoids this fundamental problem?\n\n## The Solution: Database Transactions\n\nOne way to solve the problem is to \"group\" or \"pair\" the two update\noperations somehow. We want to tell the database \"Reduce Markov's\nbalance AND increment Curie's balance.\" We want to tell the database:\n\"If for any reason you cannot perform **both** operations, make sure not\nto perform **either**.\" We want to tell the database: \"If you crash\nafter reducing Markov's balance, make sure to either (a) increase\nCurie's balance when you restart, or (b) undo the increase to Markov's\nbalance when you restart.\"\n\nWe want to ask the database to treat the pair of updates as one _atomic_\n(meaning **indivisible**) unit. SQL lets you do this using a feature\ncalled _transactions_.\n\nYou've previously seen how to use SQL transactions:\n\n```sql\nSTART TRANSACTION;\n-- Reduce Markov's balance by $7500\nUPDATE \"BankAccounts\" SET balance = balance - 7500 WHERE id = 1;\n-- Increment Curie's balance by $7500\nUPDATE \"BankAccounts\" SET balance = balance + 7500 WHERE id = 2;\nCOMMIT TRANSACTION;\n```\n\nSQL guarantees to you that everything between `START TRANSACTION` and\n`COMMIT TRANSACTION` will be processed _atomically_. If any update\noperation fails, none of the updates will be performed. The transaction\nis \"all-or-nothing.\"\n\nIn this reading you will learn how to use SQL transactions with the\nSequelize ORM.\n\n## The `BankAccounts` Schema\n\nFor our example in this reading, I will use a single table with two\naccounts.\n\n```\ncatsdb=> SELECT * FROM \"BankAccounts\";\n id | clientName | balance | ...\n----+------------+---------+-----\n  1 | Markov     |    5000 | ...\n  2 | Curie      |   10000 | ...\n(2 rows)\n```\n\nI have generated a Sequelize model corresponding to the `BankAccounts`\ntable:\n\n```javascript\n// ./models/bank_account.js\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  // Define BankAccount model.\n  const BankAccount = sequelize.define('BankAccount', {\n    // Define clientName attribute.\n    clientName: {\n      type: DataTypes.STRING,\n      allowNull: false,\n      // Define validations on clientName.\n      validate: {\n        // clientName must not be null.\n        notNull: {\n          msg: \"clientName must not be NULL\",\n        },\n        // clientName must not be empty.\n        notEmpty: {\n          msg: \"clientName must not be empty\",\n        },\n      },\n    },\n\n    // Define balance attribute.\n    balance: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n      // Define validations on balance.\n      validate: {\n        // balance must not be less than zero.\n        min: {\n          args: [0],\n          msg: \"balance must not be less than zero\",\n        },\n      },\n    },\n  }, {});\n\n  return BankAccount;\n};\n```\n\nNotice that the `min` validation on `balance` will not allow us to save\nan account balance that is below zero.\n\n## Example: An Update Fails Because Of Validation Failure\n\nLet's imagine that Markov wants to transfer $7,500 to Curie.\nUnfortunately, Markov has only $5,000 in his account! Decrementing\nMarkov's account balance by $7,500 would put it in the negative, which\nour validation will not allow. Thus the transfer must fail.\n\nImagine that Markov is unaware that his account balance cannot cover the\ntransfer. He tries to perform the transfer anyway:\n\n```javascript\n// ./index.js\nconst { sequelize , BankAccount } = require(\"./models\");\n\n// This code will try to transfer $7,500 from Markov to Curie.\nasync function main() {\n  // Fetch Markov and Curie's accounts.\n  const markovAccount = await BankAccount.findByPk(1);\n  const curieAccount = await BankAccount.findByPk(2);\n\n  try {\n    // Increment Curie's balance by $7,500.\n    curieAccount.balance += 7500;\n    await curieAccount.save();\n\n    // Decrement Markov's balance by $7,500.\n    markovAccount.balance -= 7500;\n    await markovAccount.save();\n  } catch (err) {\n    // Report if anything goes wrong.\n    console.log(\"Error!\");\n\n    for (const e of err.errors) {\n      console.log(\n        `${e.instance.clientName}: ${e.message}`\n      );\n    }\n  }\n\n  await sequelize.close();\n}\n\nmain();\n```\n\nRunning this code prints the following:\n\n```\nExecuting (default): SELECT \"id\", \"clientName\", \"balance\", \"createdAt\", \"updatedAt\" FROM \"BankAccounts\" AS \"BankAccount\" WHERE \"BankAccount\".\"id\" = 1;\nExecuting (default): SELECT \"id\", \"clientName\", \"balance\", \"createdAt\", \"updatedAt\" FROM \"BankAccounts\" AS \"BankAccount\" WHERE \"BankAccount\".\"id\" = 2;\nExecuting (default): UPDATE \"BankAccounts\" SET \"balance\"=$1,\"updatedAt\"=$2 WHERE \"id\" = $3\nError!\nMarkov: balance must not be less than zero\n```\n\nEverything starts out fine. We fetch Markov and Curie's accounts. We\nincrease Curie's balance. But then we hit a snag: when we call\n`markovAccount.save()`, Sequelize detects that we are trying to set\nMarkov's balance below zero. Sequelize therefore **does not** send a SQL\nrequest to update Markov's account balance. Instead,\n`markovAccount.save()` throws an exception. We print the error: Markov's\nbalance must not be less than zero.\n\nWe thus avoid saving a negative balance for Markov. But other damage has\nalready been done. If we now check account balances, we will see:\n\n```\ncatsdb=> SELECT * FROM \"BankAccounts\";\n id | clientName | balance | ...\n----+------------+---------+-----\n  1 | Markov     |    5000 | ...\n  2 | Curie      |   17500 | ...\n(2 rows)\n```\n\nThe bank has given free money to Curie! We should have \"rolledback\" the\nincrease of Curie's balance. We will learn how to do that!\n\n## Incorrect Solutions\n\nOne may suggest a fix: make sure to decrement Markov's account balance\nbefore incrementing Curie's balance! If Markov's balance is\ninsufficient, we can stop the transfer before giving Curie any money.\n\nWe *could* swap the order of the updates, and it would indeed fix this\nspecific problem. But imagine if Markov tries to transfer $2,500 (an\namount he can afford). We first decrement Markov's account balance and\nthen -- the operating system crashes before the second update can be\nsubmitted. Curie's balance is not incremented. The bank has stolen\nMarkov's money!\n\nThe problem is fundamental: no matter what order we perform the two\nupdates in, the database can always fail *after* processing the first,\nbut *before* processing the second. For our code to be resilient to\nunavoidable failures, there is no other choice but to use a database\ntransaction.\n\n## Using A Database Transaction With Sequelize\n\nLet's return to our previous example of trying to transfer $7,500 from\nMarkov to Curie. Specifically, we will rewrite this key part:\n\n```javascript\n// Increment Curie's balance by $7,500.\ncurieAccount.balance += 7500;\nawait curieAccount.save();\n\n// Decrement Markov's balance by $7,500.\nmarkovAccount.balance -= 7500;\nawait markovAccount.save();\n```\n\nTo ask Sequelize to perform the two updates in a SQL database\ntransaction, we use the `sequelize.transaction` method. We will write\nthis like so, instead:\n\n```javascript\nawait sequelize.transaction(async (tx) => {\n  // Increment Curie's balance by $7,500.\n  curieAccount.balance += 7500;\n  await curieAccount.save({ transaction: tx });\n\n  // Decrement Markov's balance by $7,500.\n  markovAccount.balance -= 7500;\n  await markovAccount.save({ transaction: tx });\n});\n```\n\nLet's go through the transaction code and explain each part:\n\n```javascript\n// Start a transaction. Queries run inside the callback can be part of\n// the transaction.\nawait sequelize.transaction(async (tx) => {\n  // Increment Curie's balance by $7,500.\n  curieAccount.balance += 7500;\n  // Pass the `tx` transaction object so that Sequelize knows to\n  // update Curie's account as part of this transaction (rather than\n  // \"on its own\" per usual).\n  await curieAccount.save({ transaction: tx });\n\n  // Decrement Markov's balance by $7,500.\n  markovAccount.balance -= 7500;\n  // Again, pass the `tx` transaction object. Thus both updates are part\n  // of the same transaction.\n  await markovAccount.save({ transaction: tx });\n\n  // If no exceptions have been thrown, `sequelize.transaction` will\n  // `COMMIT` the transaction after the end of the callback.\n  //\n  // If any error gets thrown, `sequelize.transaction` will abort\n  // the transaction by issuing a `ROLLBACK`. This will cancel all\n  // updates.\n});\n```\n\nLet's put the transaction code back into our original program:\n\n```javascript\n// ./index.js\nconst { sequelize, BankAccount } = require(\"./models\");\n\nasync function main() {\n  // Fetch Markov and Curie's accounts.\n  const markovAccount = await BankAccount.findByPk(1);\n  const curieAccount = await BankAccount.findByPk(2);\n\n  try {\n    await sequelize.transaction(async (tx) => {\n      // Increment Curie's balance by $7,500.\n      curieAccount.balance += 7500;\n      await curieAccount.save({ transaction: tx });\n\n      // Decrement Markov's balance by $7,500.\n      markovAccount.balance -= 7500;\n      await markovAccount.save({ transaction: tx });\n    });\n  } catch (err) {\n    // Report if anything goes wrong.\n    console.log(\"Error!\");\n\n    for (const e of err.errors) {\n      console.log(\n        `${e.instance.clientName}: ${e.message}`\n      );\n    }\n  }\n\n  await sequelize.close();\n}\n\nmain();\n```\n\nRunning this code prints:\n\n```\nExecuting (default): SELECT \"id\", \"clientName\", \"balance\", \"createdAt\", \"updatedAt\" FROM \"BankAccounts\" AS \"BankAccount\" WHERE \"BankAccount\".\"id\" = 1;\nExecuting (default): SELECT \"id\", \"clientName\", \"balance\", \"createdAt\", \"updatedAt\" FROM \"BankAccounts\" AS \"BankAccount\" WHERE \"BankAccount\".\"id\" = 2;\nExecuting (208b3951-9ab9-489b-97f0-afb49aaff807): START TRANSACTION;\nExecuting (208b3951-9ab9-489b-97f0-afb49aaff807): UPDATE \"BankAccounts\" SET \"balance\"=$1,\"updatedAt\"=$2 WHERE \"id\" = $3\nExecuting (208b3951-9ab9-489b-97f0-afb49aaff807): ROLLBACK;\nError!\nMarkov: balance must not be less than zero\n```\n\nLet's review what happened. We again start by fetching both\n`BankAccount`s. We next `START TRANSACTION`. We issue the update to\nCurie's account.\n\nThen Sequelize detects the validation failure when trying to run\n`markovAccount.save({ transaction: tx })`. Markov doesn't have enough\nmoney in his account! Sequelize throws an exception. The\n`sequelize.transaction` method *catches the exception* and issues a\n`ROLLBACK` for the transaction. This tells the database to undo the\nprior increment of Curie's account balance.\n\nHaving rolled back the transaction, the `sequelize.transaction`\nmethod *rethrows* the error, so that our logging code gets a chance to\nlearn about the error and print its details.\n\n## Aside: What Is The `Transaction` Object?\n\n_This is bonus information in case you are troubled by what the `tx`\nparameter to `sequelize.transaction` is for. You can use transactions\ncorrectly without knowing this bonus information._\n\nWhat is the mysterious `tx` that is passed by `sequelize.transaction`\nto our callback? It is basically just a unique ID. In this case, the ID\nis: `208b3951-9ab9-489b-97f0-afb49aaff807`. You can see this ID in the\nlogs above.\n\nWhen we say `curieAccount.save({ transaction: tx })`, we are telling\nSequelize: \"update Curie's account as part of transaction number\n`208b3951-9ab9-489b-97f0-afb49aaff807`.\"\n\nSequelize needs transaction IDs because it can be running many SQL\ntransactions _concurrently_ (loosely speaking: \"in parallel\"). One part\nof the application could be transferring money from Markov to Curie at\nthe same time another part of the application is transferring money from\nKate to Ned.\n\nIf Sequelize did not keep track of transaction IDs, it would not know\nthat `curieAccount.save()` should be a part of the Markov/Curie\ntransaction rather than the Kate/Ned transaction.\n\n## Transactions Prevent _Race Conditions_\n\nThere is still a subtle mistake in my bank transfer code. There is a\npotential problem if someone modifies Markov's or Curie's account in\nbetween (1) the initial fetch of their accounts, and (2) the transaction\nto update the accounts.\n\n```javascript\n// ./index.js\nasync function main() {\n  // I will transfer only $5,000 so that Markov's balance can cover the\n  // amount. Markov starts out with $5,000.\n\n  // Fetch Markov and Curie's accounts.\n  const markovAccount = await BankAccount.findByPk(1);\n  const curieAccount = await BankAccount.findByPk(2);\n\n  // ***\n  // Imagine that right now some other program transfers the $5,000 out\n  // of Markov's account. Markov's true account **in the database** now\n  // has a balance of $0. But `markovAccount.balance` is still $5,000,\n  // because we fetched Markov's `BankAccount` **before** the transfer\n  // was made!\n  // ***\n\n  try {\n    await sequelize.transaction(async (tx) => {\n      // Increment Curie's balance by $5,000 (to $15,000).\n      curieAccount.balance += 5000;\n      await curieAccount.save({ transaction: tx });\n\n      // Decrement `markovAccount.balance` by $5,000.\n      // `markovAccount.balance` is set to zero.\n      markovAccount.balance -= 5000;\n      // Save and set Markov's balance to zero.\n      await markovAccount.save({ transaction: tx });\n\n      // Problem: Markov's balance in the database was *already* zero.\n      // Markov had no money to transfer. He should not have been able\n      // to transfer the $5,000.\n    });\n  } catch (err) {\n    // ...\n  }\n\n  await sequelize.close();\n}\n\nmain();\n```\n\nBecause another program can \"race in between\" (1) the reading of the\naccount balances and (2) the updating of the balances, we call this\npotential problem a _race condition_. The easiest way to fix the race\ncondition is to prohibit anyone else from modifying Markov's account\nbalance in between (1) and (2).\n\nLuckily, the solution is simple. Any data used in a transaction will be\n_locked_ until the transaction completes. Data that is locked can be\nneither read nor written by other transactions. If our transaction reads\n(or writes) data, no one else can read or write that data until our\ntransaction completes. When we `COMMIT` (or `ROLLBACK`) all the locked\ndata is freed (the locks are _released_).\n\nWe don't have to lock the data ourselves. Simply by doing all our\nqueries inside the same transaction, the database will lock the data for\nus. Therefore, to fix the problem, we should move the initial account\nfetching by `findByPk` into the transaction (i.e., pass it `{\ntransaction: tx }`):\n\n```javascript\nasync function main() {\n  try {\n    // Do all database access within the transaction.\n    await sequelize.transaction(async (tx) => {\n      // Fetch Markov and Curie's accounts.\n      const markovAccount = await BankAccount.findByPk(\n        1, { transaction: tx },\n      );\n      const curieAccount = await BankAccount.findByPk(\n        2, { transaction: tx }\n      );\n\n      // No one can mess with Markov or Curie's accounts until the\n      // transaction completes! The account data has been locked!\n\n      // Increment Curie's balance by $5,000.\n      curieAccount.balance += 5000;\n      await curieAccount.save({ transaction: tx });\n\n      // Decrement Markov's balance by $5,000.\n      markovAccount.balance -= 5000;\n      await markovAccount.save({ transaction: tx });\n    });\n  } catch (err) {\n    // ...\n  }\n\n  await sequelize.close();\n}\n\nmain();\n```\n\nThis prints:\n\n```\nExecuting (76321a03-93c5-47c0-861a-cf24c3e6f3bf): START TRANSACTION;\nExecuting (76321a03-93c5-47c0-861a-cf24c3e6f3bf): SELECT \"id\", \"clientName\", \"balance\", \"createdAt\", \"updatedAt\" FROM \"BankAccounts\" AS \"BankAccount\" WHERE \"BankAccount\".\"id\" = 1;\nExecuting (76321a03-93c5-47c0-861a-cf24c3e6f3bf): SELECT \"id\", \"clientName\", \"balance\", \"createdAt\", \"updatedAt\" FROM \"BankAccounts\" AS \"BankAccount\" WHERE \"BankAccount\".\"id\" = 2;\nExecuting (76321a03-93c5-47c0-861a-cf24c3e6f3bf): UPDATE \"BankAccounts\" SET \"balance\"=$1,\"updatedAt\"=$2 WHERE \"id\" = $3\nExecuting (76321a03-93c5-47c0-861a-cf24c3e6f3bf): UPDATE \"BankAccounts\" SET \"balance\"=$1,\"updatedAt\"=$2 WHERE \"id\" = $3\nExecuting (76321a03-93c5-47c0-861a-cf24c3e6f3bf): COMMIT;\n```\n\nNotice that now *everything* is done in the transaction\n`76321a03-93c5-47c0-861a-cf24c3e6f3bf`. This includes the initial\nfetching of the accounts. Because the fetching is done within the\ntransaction, other users are not allowed to modify the accounts until\nthe transaction is finished.\n\nMoving our read operations into the transaction has solved our race\ncondition problem. Every Sequelize operation - whether reading or\nwriting - can take a `transaction: tx` option. This includes:\n\n1. `findByPk`\n1. `findAll`\n1. `save`\n1. `create`\n1. `destroy`\n\n## Conclusion\n\nHaving completed this reading, here are the important things to take\naway:\n\n1. You should know that any SQL update operation may fail, often through\n   no fault of your own.\n1. You should know that you must write code resilient to SQL failures.\n1. You should know that when performing multiple update operations as\n   part of a group, you must use a transaction.\n1. You should know how to use `sequelize.transaction` to run commands\n   within a SQL transaction.\n1. You should know how to pass a transaction object as the\n   `{ transaction: tx }` parameter to a Sequelize command (such as\n   `save`).\n1. You should know what a _race condition_ is: the possibility that\n   someone else modifies previously fetched data before you are finished\n   using/updating it.\n1. You should know how to use transactions to guard against race\n   conditions. That is: you should know that both reading and writing\n   operations should be put in the same transaction.\n"
  },
  "success": true
}