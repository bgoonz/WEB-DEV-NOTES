<h1 id="week-10-day-3-deeper-into-data-________________________________">WEEK-10 DAY-3<br><em>Deeper Into Data</em> ________________________________ <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=2 orderedList=false} --></h1>
<hr />
<h1 id="orm-learning-objectives">ORM Learning Objectives</h1>
<p>In this section, you will learn:</p>
<ul>
<li>How to install, configure, and use Sequelize, an ORM for JavaScript * How to use database migrations to make your database grow with your application in a source-control enabled way * How to perform CRUD operations with Sequelize * How to query using Sequelize * How to perform data validations with Sequelize * How to use transactions with Sequelize</li>
</ul>
<hr />
<h1 id="creating-a-schema-for-relational-database-design">Creating A Schema For Relational Database Design</h1>
<p>Schemas allow use to easily visualize database tables and their relationships to one another, so that we can identify areas that need clarity, refinement, or redesign.</p>
<p>In this reading, we’re going to cover the stages of relational database design and how to create schema that depicts database table relationships.</p>
<h2 id="what-is-relational-database-design">What is Relational Database Design?</h2>
<p>According to Technopedia, <a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">Relational Database Design</a> (or RDD) differs from other databases in terms of data organization and transactions: <strong>“In an RDD, the data are organized into tables and all types of data access are carried out via controlled transactions.”</strong></p>
<p>In previous readings, we created relational database tables and accessed data from these tables through PostgreSQL queries.</p>
<p>These<strong>tables (a.k.a. <em>entities</em>)</strong> contain <strong>rows (a.k.a. <em>records</em>)</strong> and <strong>columns (a.k.a. <em>fields</em>)</strong>. We also learned how to uniquely identify table records by adding a <code>PRIMARY KEY</code> and how to create a table association by adding a <code>FOREIGN KEY</code>.</p>
<p>A <strong>relational database usually contains multiple tables</strong>. It’s useful to create schema to help us visualize these tables, keep track of primary keys and foreign keys, and create relationships among tables.</p>
<h2 id="stages-of-relational-database-design">Stages of Relational Database Design</h2>
<p>There are four generally-agreed-upon stages of Relational Database Design:</p>
<ol type="1">
<li>Define the purpose/entities of the relational DB. 2. Identify primary keys. 3. Establish table relationships. 4. Apply normalization rules.</li>
</ol>
<h3 id="define-database-purpose-and-entities">1. Define database purpose and entities</h3>
<p>The first stage is identifying the purpose of the database (<em>Why is the database being created? What problem is it solving? What is the data used for?</em>), as well as identifying the <strong>main entities, or <em>tables</em></strong>, that need to be created. It also typically involves identifying the <strong>table’s attributes (i.e. <em>columns</em> and <em>rows</em>)</strong>.</p>
<p>For example, if we were creating a database for order processing on an e-commerce application, we would need a database with at least three tables: a <code>products</code> table, an <code>orders</code> tables, and a <code>users</code> (i.e. customers) table. We know that a product will probably have an ID, name, and price, and an order will contain one or more product IDs. We also know that users can create multiple orders.</p>
<p>[Orders ERD entities]</p>
<h3 id="identify-primary-keys">2. Identify primary keys</h3>
<p>The second stage is to identify the primary key (<em>PK</em>) of each table. As we previously learned, a table’s primary key contains a unique value, or values, that identify each distinct record. For our above example of online orders, we would probably create IDs to serve as the primary key for each table: a product ID, an order ID, and a user ID.</p>
<p>[orders-erd-primary-keys.svg]</p>
<h3 id="establish-table-relationships">3. Establish table relationships</h3>
<p>The third stage is to establish the relationships among the tables in the database. There are three types of relational database table relationships:</p>
<ul>
<li>One-to-one - One-to-many - Many-to-many</li>
</ul>
<p><strong>One-to-one relationship</strong></p>
<p>In a one-to-one relationship, one record in a table is associated with only one record in another table. We could say that only one record in Table B belongs to only one record in Table A.</p>
<p>A one-to-one relationship is the least common type of table relationship. While the two tables above could be combined into a single table, we may want to keep some less-used data separate from the main <code>products</code> table.</p>
<p>[products-erd-one-to-one.svg]</p>
<p>The above schema depicts two tables: a “products” table and a “product_details” table. A <code>product_details</code> record belongs to only one product record. We’ve used an arrow to indicate the one-to-one relationship between the tables. Both tables have the same primary key – <code>product_id</code> – which we can use in a <a href="http://www.postgresqltutorial.com/postgresql-inner-join/"><code>JOIN</code></a> operation to get data from both tables.</p>
<p>This table relationship would produce the following example data (note that not all columns are shown below): <strong>Products</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1597</td>
<td>Glass Coffee Mug</td>
</tr>
<tr class="even">
<td>1598</td>
<td>Metallic Coffee Mug</td>
</tr>
<tr class="odd">
<td>1599</td>
<td>Smart Coffee Mug</td>
</tr>
</tbody>
</table>
<p><strong>Product Details</strong></p>
<div class="line-block">id | product_id | full_description | |—-|————|———————————————————————————————————————————————————————————————————-| | 1 | 1597 | Sturdy tempered glass coffee mug with natural cork band and silicone lid. Barista standard - fits under commercial coffee machine heads and most cup-holders. | | 2 | 1598 | Fun coffee mug that comes in various metallic colors. Sleek, stylish, and easy to wash. Makes a great addition to your kitchen. Take it on the go by attaching the secure lid. | | 3 | 1599 | This smart mug goes beyond being a simple coffee receptacle. Its smart features let you set and maintain an exact drinking temperature for up to 1.5 hours, so your coffee is never too hot or too cold. |</div>
<p>Take a moment to analyze the data above. Using the foreign keys, you should be able to reason out that the “Metallic Coffee Mug” is a “Fun coffee mug that comes in various metallic colors.”</p>
<p><strong>One-to-many relationship</strong></p>
<p>In a one-to-many relationship, each record in Table A is associated with multiple records in Table B. Each record in Table B is associated with only one record in Table A.</p>
<p>[orders-erd-one-to-many.svg]</p>
<p>The above schema depicts a one-to-many relationship between the “users” table and the <code>orders</code> table: One user can create multiple orders. The primary key of the “orders” table (<code>id</code>) is a foreign key in the “users” table (<code>order_id</code>). We can use this foreign key in a <code>JOIN</code> operation to get data from both tables.</p>
<p>This table relationship would produce the following example data (note that not all columns are shown below):</p>
<p><strong>Users</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Alice</td>
</tr>
<tr class="even">
<td>2</td>
<td>Bob</td>
</tr>
</tbody>
</table>
<p><strong>Orders</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>purchaser_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>1</td>
</tr>
<tr class="even">
<td>11</td>
<td>1</td>
</tr>
<tr class="odd">
<td>12</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Take a moment to analyze the data above. Using the foreign keys, you should be able to reason out that “Alice” has made two orders and “Bob” has made one order.</p>
<p><strong>Many-to-many relationship</strong></p>
<p>In a many-to-many relationship, multiple records in Table A are associated with multiple records in Table B. You would normally create a third table for this relationship called a <em><strong>join table</strong></em>, which contains the primary keys from both tables.</p>
<p>[orders-erd-many-to-many.svg]</p>
<p>The above schema depicts a many-to-many relationship between the <code>products</code> table and the <code>orders</code> table. A single order can have multiple products, and a single product can belong to multiple orders. We created a third join table called <code>order_details</code>, which contains both the<code>order_id</code> and <code>product_id</code> fields as foreign keys.</p>
<p>This table relationship would produce the following example data(note that not all columns are shown below):</p>
<p><strong>Products</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1597</td>
<td>Glass Coffee Mug</td>
</tr>
<tr class="even">
<td>1598</td>
<td>Metallic Coffee Mug</td>
</tr>
<tr class="odd">
<td>1599</td>
<td>Smart Coffee Mug</td>
</tr>
</tbody>
</table>
<p><strong>Users</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Alice</td>
</tr>
<tr class="even">
<td>2</td>
<td>Bob</td>
</tr>
</tbody>
</table>
<p><strong>Orders</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>purchaser_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>1</td>
</tr>
<tr class="even">
<td>11</td>
<td>1</td>
</tr>
<tr class="odd">
<td>12</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>Order Details</strong></p>
<table>
<thead>
<tr class="header">
<th>id</th>
<th>order_id</th>
<th>product_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>10</td>
<td>1599</td>
</tr>
<tr class="even">
<td>2</td>
<td>11</td>
<td>1597</td>
</tr>
<tr class="odd">
<td>3</td>
<td>11</td>
<td>1598</td>
</tr>
<tr class="even">
<td>4</td>
<td>12</td>
<td>1597</td>
</tr>
<tr class="odd">
<td>5</td>
<td>12</td>
<td>1598</td>
</tr>
<tr class="even">
<td>6</td>
<td>12</td>
<td>1599</td>
</tr>
</tbody>
</table>
<p>Take a moment to analyze the data above. Using the foreign keys, you should be able to reason out that “Alice” has two orders. One order containing a “Smart Coffee Mug” and another order containing both a “Glass Coffee Mug” and “Metallic Coffee Mug”.</p>
<h3 id="apply-normalization-rules">4. Apply normalization rules</h3>
<p>The fourth stage in RDD is <em><strong>normalization</strong></em>. Normalization is the process of optimizing the database structure so that redundancy and confusion are eliminated.</p>
<p>The rules of normalization are called “normal forms” and are as follows:</p>
<ol type="1">
<li>First normal form 2. Second normal form 3. Third normal form 4. Boyce-Codd normal form 5. Fifth normal form</li>
</ol>
<p>The first three forms are widely used in practice, while the fourth and fifth are less often used.</p>
<p><strong>First normal form rules:</strong></p>
<ul>
<li>Eliminate repeating groups in individual tables. - Create a separate table for each set of related data. - Identify each set of related data with a primary key.</li>
</ul>
<p><strong>Second normal form rules:</strong></p>
<ul>
<li>Create separate tables for sets of values that apply to multiple records. - Relate these tables with a foreign key.</li>
</ul>
<p><strong>Third normal form rules:</strong></p>
<ul>
<li>Eliminate fields that do not depend on the table’s key.</li>
</ul>
<p><em>Note: For examples of how to apply these forms, read <a href="http://www.postgresqltutorial.com/postgresql-joins/">“Description of the database normalization basics”</a> from Microsoft.</em></p>
<h2 id="schema-design-tools">Schema design tools</h2>
<p>Many people draw their relational database design schema with good ol’ pen and paper, or on a whiteboard. However, there are also lots of online tools created for this purpose if you’d like to use something easily exportable/shareable. Feel free to check out the ERD (short for “Entity Relationship Diagram”) tools below.</p>
<p>Free Database Diagram (ERD) Design Tools:</p>
<ul>
<li><a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">Lucidchart</a> - <a href="http://www.postgresqltutorial.com/postgresql-in/">draw.io</a> - <a href="https://crate.io/a/sql-subquery-vs-left-join/">dbdiagram.io</a> - <a href="http://www.postgresqltutorial.com/postgresql-subquery/">QuickDBD</a></li>
</ul>
<h2 id="what-we-learned">What we learned:</h2>
<ul>
<li>Stages of Relational Database Design (RDD) - Examples of schema depicting table relationships - Normalization rules - Schema drawing tools</li>
</ul>
<p><a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">1</a>: https://www.techopedia.com/definition/25113/relational-database-design-rdd <a href="http://www.postgresqltutorial.com/postgresql-inner-join/">2</a>: https://www.postgresql.org/docs/8.3/tutorial-join.html <a href="http://www.postgresqltutorial.com/postgresql-joins/">3</a>: https://support.microsoft.com/en-us/help/283878/description-of-the-database-normalization-basics <a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">4</a>: https://www.lucidchart.com/ <a href="http://www.postgresqltutorial.com/postgresql-in/">5</a>: https://www.draw.io/ <a href="https://crate.io/a/sql-subquery-vs-left-join/">6</a>: https://dbdiagram.io/home?utm_source=holistics&amp;utm_medium=top_5_tools_blog <a href="http://www.postgresqltutorial.com/postgresql-subquery/">7</a>: https://www.quickdatabasediagrams.com/</p>
<p>[Orders ERD entities]: images/orders-erd-entities.svg [orders-erd-primary-keys.svg]: images/orders-erd-primary-keys.svg [products-erd-one-to-one.svg]: images/products-erd-one-to-one.svg [orders-erd-one-to-many.svg]: images/orders-erd-one-to-many.svg [orders-erd-many-to-many.svg]: images/orders-erd-many-to-many.svg ________________________________________________ # Using SQL Transactions</p>
<p>Transactions allow us to make changes to a SQL database in a consistent and durable way, and it’s a best practice to use them regularly.</p>
<p>In this reading, we’ll cover what a transaction is and why we want to use it, as well as how to write explicit transactions.</p>
<h2 id="what-is-a-transaction">What is a transaction?</h2>
<p>A transaction is a single unit of work, which can contain multiple operations, performed on a database. According to the <a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">PostgreSQL docs</a>, the important thing to note about a transaction is that “it bundles multiple steps into a single, all-or-nothing operation”. If any operation within the transaction fails, then the entire transaction fails. If all the operations succeed, then the entire transaction succeeds.</p>
<h2 id="implicit-vs.-explicit-transactions">Implicit vs. explicit transactions</h2>
<p>Every SQL statement is effectively a transaction. When you insert a new table row into a database table, for example, you are creating a transaction. The following <code>INSERT</code> statement is a transaction:</p>
<p><code>sql INSERT INTO hobbits(name,purpose) VALUES('Frodo','Destroy the One Ring of power.');</code></p>
<p>The above code is known as an <em>implicit</em> transaction. With an implicit transaction, changes to the database happen immediately, and we have no way to undo or roll back these changes. We can only make subsequent changes/ transactions.</p>
<p>An <em>explicit</em> transaction, however, allows us to create save points and roll back to whatever point in time we choose. An explicit transaction begins with the command <code>BEGIN</code>, followed by the SQL statement, and then ends with either a <code>COMMIT</code> or <code>ROLLBACK</code>.</p>
<h3 id="postgresql-transactional-commands">PostgreSQL transactional commands</h3>
<p><strong><a href="http://www.postgresqltutorial.com/postgresql-joins/">BEGIN</a></strong> – Initiates a transaction block. All statements after a BEGIN command will be executed in a single transaction until an explicit COMMIT or ROLLBACK is given.</p>
<p>Starting a transaction:</p>
<p><code>sql BEGIN; INSERT INTO hobbits(name,purpose) VALUES('Frodo','Destroy the One Ring of power.');</code></p>
<p><strong><a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">COMMIT</a></strong> – Commits the current transaction. All changes made by the transaction become visible to others and are guaranteed to be durable if a crash occurs.</p>
<p>Committing a transaction:</p>
<p><code>sql BEGIN; INSERT INTO hobbits(name,purpose) VALUES('Frodo','Destroy the One Ring of power.'); COMMIT;</code></p>
<p><strong><a href="http://www.postgresqltutorial.com/postgresql-in/">ROLLBACK</a></strong> – Rolls back the current transaction and causes all the updates made by the transaction to be discarded. Can only undo transactions since the last COMMIT or ROLLBACK command was issued.</p>
<p>Rolling back a transaction (i.e. abort all changes):</p>
<p><code>sql BEGIN; INSERT INTO hobbits(name,purpose) VALUES('Frodo','Destroy the One Ring of power.'); ROLLBACK;</code></p>
<p><strong><a href="https://crate.io/a/sql-subquery-vs-left-join/">SAVEPOINT</a></strong> – Establishes a new save point within the current transaction. Allows all commands executed after the save point to be rolled back, restoring the transaction state to what it was at the time of the save point.</p>
<p>Syntax to create save point: <code>SAVEPOINT savepoint_name;</code> Syntax to delete a save point: <code>RELEASE SAVEPOINT savepoint_name;</code></p>
<p>Let’s say we had the following table called <code>fellowship</code>:</p>
<table>
<thead>
<tr class="header">
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Frodo</td>
<td>50</td>
</tr>
<tr class="even">
<td>Samwise</td>
<td>38</td>
</tr>
<tr class="odd">
<td>Merry</td>
<td>36</td>
</tr>
<tr class="even">
<td>Pippin</td>
<td>28</td>
</tr>
<tr class="odd">
<td>Aragorn</td>
<td>87</td>
</tr>
<tr class="even">
<td>Boromir</td>
<td>40</td>
</tr>
<tr class="odd">
<td>Legolas</td>
<td>2000</td>
</tr>
<tr class="even">
<td>Gandalf</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p>We’ll create a transaction on this table containing a few operations. Inside the transaction, we’ll establish a save point that we’ll roll back to before committing.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb1-1" title="1"><span class="cf">BEGIN</span>;</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">DELETE</span> <span class="kw">FROM</span> fellowship</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">WHERE</span> age <span class="op">&gt;</span> <span class="dv">100</span>;</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">SAVEPOINT</span> first_savepoint;</a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="kw">DELETE</span> <span class="kw">FROM</span> fellowship</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">WHERE</span> age <span class="op">&gt;</span> <span class="dv">80</span>;</a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="kw">DELETE</span> <span class="kw">FROM</span> fellowship</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">WHERE</span> age <span class="op">&gt;=</span> <span class="dv">40</span>;</a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="kw">ROLLBACK</span> <span class="kw">TO</span> first_savepoint;</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">COMMIT</span>;</a></code></pre></div>
<p>Once our transaction is committed, our table would look like this:</p>
<table>
<thead>
<tr class="header">
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Frodo</td>
<td>50</td>
</tr>
<tr class="even">
<td>Samwise</td>
<td>38</td>
</tr>
<tr class="odd">
<td>Merry</td>
<td>36</td>
</tr>
<tr class="even">
<td>Pippin</td>
<td>28</td>
</tr>
<tr class="odd">
<td>Aragorn</td>
<td>87</td>
</tr>
<tr class="even">
<td>Boromir</td>
<td>40</td>
</tr>
</tbody>
</table>
<p>We can see that the deletion that happened just prior to the savepoint creation was preserved.</p>
<p><strong><a href="http://www.postgresqltutorial.com/postgresql-subquery/">SET TRANSACTION</a></strong> – Sets the characteristics of the current transaction. (_Note: To set characteristics for subsequent transactions in a session, use <code>SET SESSION   CHARACTERISTICS</code>.) The available transaction characteristics are the transaction isolation level, the transaction access mode (read/write or read-only), and the deferrable mode. (<em>Read more about these characteristics in the <a href="http://www.postgresqltutorial.com/postgresql-subquery/">PostgreSQL docs</a>.</em>)</p>
<p>Example of setting transaction characteristics:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb2-1" title="1"><span class="cf">BEGIN</span>;</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">SET</span> <span class="kw">TRANSACTION</span> <span class="kw">READ</span> <span class="kw">ONLY</span>;</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="op">..</span>.</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">COMMIT</span>;</a></code></pre></div>
<h2 id="when-to-use-transactions-and-why">When to use transactions and why</h2>
<p>It is generally a good idea to use explicit SQL transactions when making any updates, insertions, or deletions, to a database. However, you generally wouldn’t write an explicit transaction for a simple <code>SELECT</code> query.</p>
<p>Transactions help you deal with crashes, failures, data consistency, and error handling. The ability to create savepoints and roll back to earlier points is tremendously helpful when doing multiple updates and helps maintain data integrity.</p>
<p>Another benefit of transactions is the <em><strong>atomic</strong></em>, or “all-or-nothing”, nature of their operations. Because all of the operations in a transaction must succeed or else be aborted, partial or incomplete updates to the database will not be made. End-users will see only the final result of the transaction.</p>
<h2 id="transaction-properties-acid">Transaction properties: ACID</h2>
<p>A SQL transaction has four properties known collectively as “ACID” – which is an acronym for <em>Atomic, Consistent, Isolated, and Durable</em>. The following descriptions come from the IBM doc “<a href="http://www.postgresqltutorial.com/postgresql-inner-join/">ACID properties of transactions</a>”:</p>
<p><strong>Atomicity</strong> – All changes to data are performed as if they are a single operation. That is, all the changes are performed, or none of them are.</p>
<p>For example, in an application that transfers funds from one account to another, the atomicity property ensures that, if a debit is made successfully from one account, the corresponding credit is made to the other account.</p>
<p><strong>Consistency</strong> – Data is in a consistent state when a transaction starts and when it ends.</p>
<p>For example, in an application that transfers funds from one account to another, the consistency property ensures that the total value of funds in both the accounts is the same at the start and end of each transaction.</p>
<p><strong>Isolation</strong> – The intermediate state of a transaction is invisible to other transactions. As a result, transactions that run concurrently appear to be serialized.</p>
<p>For example, in an application that transfers funds from one account to another, the isolation property ensures that another transaction sees the transferred funds in one account or the other, but not in both, nor in neither.</p>
<p><strong>Durability</strong> – After a transaction successfully completes, changes to data persist and are not undone, even in the event of a system failure.</p>
<p>For example, in an application that transfers funds from one account to another, the durability property ensures that the changes made to each account will not be reversed.</p>
<h3 id="banking-transaction-example">Banking transaction example</h3>
<p>Let’s look at an example from the <a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">PostgreSQL Transactions doc</a> that demonstrates the ACID properties of a transaction. We have a bank database that contains customer account balances, as well as total deposit balances for branches. We want to record a payment of $100.00 from Alice’s account to Bob’s account, as well as update the total branch balances. The transaction would look like the code below.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb3-1" title="1"><span class="cf">BEGIN</span>;</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">UPDATE</span> accounts <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">-</span> <span class="fl">100.00</span></a>
<a class="sourceLine" id="cb3-3" title="3">      <span class="kw">WHERE</span> name <span class="op">=</span> <span class="st">&#39;Alice&#39;</span>;</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="kw">UPDATE</span> branches <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">-</span> <span class="fl">100.00</span></a>
<a class="sourceLine" id="cb3-5" title="5">      <span class="kw">WHERE</span> name <span class="op">=</span> (<span class="kw">SELECT</span> branch_name <span class="kw">FROM</span> accounts <span class="kw">WHERE</span> name <span class="op">=</span> <span class="st">&#39;Alice&#39;</span>);</a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="kw">UPDATE</span> accounts <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">+</span> <span class="fl">100.00</span></a>
<a class="sourceLine" id="cb3-7" title="7">      <span class="kw">WHERE</span> name <span class="op">=</span> <span class="st">&#39;Bob&#39;</span>;</a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="kw">UPDATE</span> branches <span class="kw">SET</span> balance <span class="op">=</span> balance <span class="op">+</span> <span class="fl">100.00</span></a>
<a class="sourceLine" id="cb3-9" title="9">      <span class="kw">WHERE</span> name <span class="op">=</span> (<span class="kw">SELECT</span> branch_name <span class="kw">FROM</span> accounts <span class="kw">WHERE</span> name <span class="op">=</span> <span class="st">&#39;Bob&#39;</span>);</a>
<a class="sourceLine" id="cb3-10" title="10"><span class="kw">COMMIT</span>;</a></code></pre></div>
<p>There are several updates happening above. The bank wants to make sure that all of the updates happen or none happen, in order to ensure that funds are transferred from the proper account (i.e. Alice’s account) to the proper recipient’s account (i.e. Bob’s account). If any of the updates fails, none of them will take effect. That is, if something goes wrong either with withdrawing funds from Alice’s account or transferring the funds into Bob’s account, then the entire transaction will be aborted and no changes will occur. This prevents Alice or Bob from seeing a transaction in their account summaries that isn’t supposed to be there.</p>
<p>There are many other scenarios where we would want to use an atomic operation to ensure a successful end result. Transactions are ideal for such scenarios, and we should use them whenever they’re applicable.</p>
<h2 id="helpful-links">Helpful links:</h2>
<ul>
<li><a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">PostgreSQL: Transactions</a></li>
<li><a href="https://www.postgresql.org/docs/8.3/functions-subquery.html">PostgreSQL Tutorial: PostgreSQL Transaction</a></li>
<li><a href="http://www.postgresqltutorial.com/postgresql-joins/">PostgreSQL: BEGIN</a></li>
<li><a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">PostgreSQL: COMMIT</a></li>
<li><a href="http://www.postgresqltutorial.com/postgresql-in/">PostgreSQL: ROLLBACK</a></li>
<li><a href="https://crate.io/a/sql-subquery-vs-left-join/">PostgreSQL: SAVEPOINT</a></li>
<li><a href="https://crate.io/a/sql-subquery-vs-left-join/">PostgreSQL: SET TRANSACTION</a></li>
</ul>
<h1 id="joins-vs.-subqueries">Joins vs. Subqueries</h1>
<p>To select, or not to select? That is the query. We’ve barely scratched the surface of SQL queries. Previously, we went over how to write simple SQL queries using the <code>SELECT</code> statement, and we learned how to incorporate a <code>WHERE</code> clause into our queries.</p>
<p>There’s a lot more we could add to our queries to get more refined results. In this reading, we’ll go over joins and subqueries and talk about when we would use one over the other.</p>
<h2 id="what-is-a-join">What is a JOIN?</h2>
<p>We briefly looked at the <code>JOIN</code> operation after we created foreign keys in a previous reading. The <a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">JOIN operation</a> allows us to retrieve rows from multiple tables.</p>
<p>To review, we had two tables: a “breeds” table and a “puppies” table. The two tables shared information through a foreign key. The foreign key <code>breed_id</code> lives on the “puppies” table and is related to the primary key <code>id</code> of the “breeds” table.</p>
<p>We wrote the following <code>INNER JOIN</code> operation to get only the rows from the “puppies” table with a matching <code>breed_id</code> in the “friends” table:</p>
<p><code>sql SELECT * FROM puppies INNER JOIN breeds ON (puppies.breed_id = breeds.id);</code></p>
<p><a href="http://www.postgresqltutorial.com/postgresql-inner-join/">INNER JOIN</a> can be represented as a Venn Diagram, which produces rows from Table A that match some information in Table B.</p>
<figure>
<img src="images/inner-join-venn-diagram.png" alt="inner-join-venn-diagram" /><figcaption>inner-join-venn-diagram</figcaption>
</figure>
<p>We got the following table rows back from our <code>INNER JOIN</code> on the “puppies” table. These rows represent the center overlapping area of the two circles. We can see that the data from “puppies” appears first, followed by the joined data from the “friends” table.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb4-1" title="1"> <span class="kw">id</span> |   name   | age_yrs | breed_id | weight_lbs | microchipped | <span class="kw">id</span> |        name</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">----+----------+---------+----------+------------+--------------+----+---------------------</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="dv">1</span> | Cooper   |     <span class="fl">1.0</span> |        <span class="dv">8</span> |         <span class="dv">18</span> | t            |  <span class="dv">8</span> | Miniature Schnauzer</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="dv">2</span> | Indie    |     <span class="fl">0.5</span> |        <span class="dv">9</span> |         <span class="dv">13</span> | t            |  <span class="dv">9</span> | Yorkshire Terrier</a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="dv">3</span> | Kota     |     <span class="fl">0.7</span> |        <span class="dv">1</span> |         <span class="dv">26</span> | f            |  <span class="dv">1</span> | Australian Shepherd</a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="dv">4</span> | Zoe      |     <span class="fl">0.8</span> |        <span class="dv">6</span> |         <span class="dv">32</span> | t            |  <span class="dv">6</span> | Korean Jindo</a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="dv">5</span> | Charley  |     <span class="fl">1.5</span> |        <span class="dv">2</span> |         <span class="dv">25</span> | f            |  <span class="dv">2</span> | Basset Hound</a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="dv">6</span> | Ladybird |     <span class="fl">0.6</span> |        <span class="dv">7</span> |         <span class="dv">20</span> | t            |  <span class="dv">7</span> | Labradoodle</a>
<a class="sourceLine" id="cb4-9" title="9">  <span class="dv">7</span> | Callie   |     <span class="fl">0.9</span> |        <span class="dv">4</span> |         <span class="dv">16</span> | f            |  <span class="dv">4</span> | Corgi</a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="dv">8</span> | Jaxson   |     <span class="fl">0.4</span> |        <span class="dv">3</span> |         <span class="dv">19</span> | t            |  <span class="dv">3</span> | Beagle</a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="dv">9</span> | Leinni   |     <span class="fl">1.0</span> |        <span class="dv">8</span> |         <span class="dv">25</span> | t            |  <span class="dv">8</span> | Miniature Schnauzer</a>
<a class="sourceLine" id="cb4-12" title="12"> <span class="dv">10</span> | <span class="fu">Max</span>      |     <span class="fl">1.6</span> |        <span class="dv">5</span> |         <span class="dv">65</span> | f            |  <span class="dv">5</span> | German Shepherd</a></code></pre></div>
<p>There are different types of <code>JOIN</code> operations. The ones you’ll use most often are:</p>
<ol type="1">
<li><strong>Inner Join</strong> – Returns a result set containing rows in the left table that match rows in the right table.</li>
<li><strong>Left Join</strong> – Returns a result set containing all rows from the left table with the matching rows from the right table. If there is no match, the right side will have null values.</li>
<li><strong>Right Join</strong> – Returns a result set containing all rows from the right table with matching rows from the left table. If there is no match, the left side will have null values.</li>
<li><strong>Full Outer Join</strong> – Returns a result set containing all rows from both the left and right tables, with the matching rows from both sides where available. If there is no match, the missing side contains null values.</li>
<li><strong>Self-Join</strong> – A self-join is a query in which a table is joined to itself. Self-joins are useful for comparing values in a column of rows within the same table.</li>
</ol>
<p>(<em>See this tutorial doc on <a href="http://www.postgresqltutorial.com/postgresql-joins/">PostgreSQL Joins</a> for more information on the different <code>JOIN</code> operations.</em>)</p>
<h2 id="what-is-a-subquery">What is a subquery?</h2>
<p>A subquery is essentially a <code>SELECT</code> statement nested inside another <code>SELECT</code> statement. A subquery can return a single (“scalar”) value or multiple rows.</p>
<h3 id="single-value-subquery">Single-value subquery</h3>
<p>Let’s see an example of how to use a subquery to return a single value. Take the “puppies” table from before. We had a column called <code>age_yrs</code> in that table (see below).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb5-1" title="1">postgres<span class="op">=</span># <span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> puppies;</a>
<a class="sourceLine" id="cb5-2" title="2"> <span class="kw">id</span> |   name   | age_yrs | breed_id | weight_lbs | microchipped</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">----+----------+---------+----------+------------+--------------</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="dv">1</span> | Cooper   |     <span class="fl">1.0</span> |        <span class="dv">8</span> |         <span class="dv">18</span> | t</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="dv">2</span> | Indie    |     <span class="fl">0.5</span> |        <span class="dv">9</span> |         <span class="dv">13</span> | t</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="dv">3</span> | Kota     |     <span class="fl">0.7</span> |        <span class="dv">1</span> |         <span class="dv">26</span> | f</a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="dv">4</span> | Zoe      |     <span class="fl">0.8</span> |        <span class="dv">6</span> |         <span class="dv">32</span> | t</a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="dv">5</span> | Charley  |     <span class="fl">1.5</span> |        <span class="dv">2</span> |         <span class="dv">25</span> | f</a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="dv">6</span> | Ladybird |     <span class="fl">0.6</span> |        <span class="dv">7</span> |         <span class="dv">20</span> | t</a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="dv">7</span> | Callie   |     <span class="fl">0.9</span> |        <span class="dv">4</span> |         <span class="dv">16</span> | f</a>
<a class="sourceLine" id="cb5-11" title="11">  <span class="dv">8</span> | Jaxson   |     <span class="fl">0.4</span> |        <span class="dv">3</span> |         <span class="dv">19</span> | t</a>
<a class="sourceLine" id="cb5-12" title="12">  <span class="dv">9</span> | Leinni   |     <span class="fl">1.0</span> |        <span class="dv">8</span> |         <span class="dv">25</span> | t</a>
<a class="sourceLine" id="cb5-13" title="13"> <span class="dv">10</span> | <span class="fu">Max</span>      |     <span class="fl">1.6</span> |        <span class="dv">5</span> |         <span class="dv">65</span> | f</a>
<a class="sourceLine" id="cb5-14" title="14">(<span class="dv">10</span> <span class="kw">rows</span>)</a></code></pre></div>
<p>We’ll use the <a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">PostgreSQL aggregate function</a> <code>AVG</code> to get an average puppy age.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">SELECT</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="fu">AVG</span> (age_yrs)</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">FROM</span></a>
<a class="sourceLine" id="cb6-4" title="4">  puppies;</a></code></pre></div>
<p>Assuming our previous “puppies” table still exists in our database, if we entered the above statement into psql we’d get an <em><strong>average age of 0.9</strong></em>. (<em>Note: Try it out yourself in psql! Refer to the reading “Retrieving Rows From A Table Using SELECT” if you need help remembering how we set up the “puppies” table.</em>)</p>
<p>Let’s say that we wanted to find all of the puppies that are older than the average age of 0.9. We could write the following query:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">SELECT</span></a>
<a class="sourceLine" id="cb7-2" title="2">  name,</a>
<a class="sourceLine" id="cb7-3" title="3">  age_yrs,</a>
<a class="sourceLine" id="cb7-4" title="4">  breed</a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">FROM</span></a>
<a class="sourceLine" id="cb7-6" title="6">  puppies</a>
<a class="sourceLine" id="cb7-7" title="7"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb7-8" title="8">  age_yrs <span class="op">&gt;</span> <span class="fl">0.9</span>;</a></code></pre></div>
<p>In the above query, we compared <code>age_yrs</code> to an actual number (0.9). However, as more puppies get added to our table, the average age could change at any time. To make our statement more dynamic, we can plug in the query we wrote to find the average age into another statement as a <em>subquery</em> (surrounded by parentheses).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">SELECT</span></a>
<a class="sourceLine" id="cb8-2" title="2">  puppies.name,</a>
<a class="sourceLine" id="cb8-3" title="3">  age_yrs,</a>
<a class="sourceLine" id="cb8-4" title="4">  breeds.name</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">FROM</span></a>
<a class="sourceLine" id="cb8-6" title="6">  puppies</a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">INNER</span> <span class="kw">JOIN</span></a>
<a class="sourceLine" id="cb8-8" title="8">  breeds <span class="kw">ON</span> (breeds.<span class="kw">id</span> <span class="op">=</span> puppies.breed_id)</a>
<a class="sourceLine" id="cb8-9" title="9"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb8-10" title="10">  age_yrs <span class="op">&gt;</span> (</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">SELECT</span></a>
<a class="sourceLine" id="cb8-12" title="12">      <span class="fu">AVG</span> (age_yrs)</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="kw">FROM</span></a>
<a class="sourceLine" id="cb8-14" title="14">      puppies</a>
<a class="sourceLine" id="cb8-15" title="15">  );</a></code></pre></div>
<p>We should get the following table rows, which include only the puppies older than 9 months:</p>
<pre class="shell"><code>  name   | age_yrs |        breed
---------+---------+---------------------
 Cooper  |     1.0 | Miniature Schnauzer
 Charley |     1.5 | Basset Hound
 Leinni  |     1.0 | Miniature Schnauzer
 Max     |     1.6 | German Shepherd</code></pre>
<h3 id="multiple-row-subquery">Multiple-row subquery</h3>
<p>We could also write a subquery that returns multiple rows.</p>
<p>In the reading “Creating A Table In An Existing PostgreSQL Database”, we created a “friends” table. In “Foreign Keys And The JOIN Operation”, we set up a primary key in the “puppies” table that is a foreign key in the “friends” table – <code>puppy_id</code>. We’ll use this ID in our subquery and outer query. <strong>“friends” table</strong></p>
<pre class="shell"><code>id | first_name | last_name | puppy_id
----+------------+-----------+----------
  1 | Amy        | Pond      |        4
  2 | Rose       | Tyler     |        5
  3 | Martha     | Jones     |        6
  4 | Donna      | Noble     |        7
  5 | River      | Song      |        8</code></pre>
<p>Let’s say we wanted to find all the puppies that are younger than 6 months old.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">SELECT</span> puppy_id</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">FROM</span> puppies</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb11-4" title="4">  age_yrs <span class="op">&lt;</span> <span class="fl">0.6</span>;</a></code></pre></div>
<p>This would return two rows:</p>
<p>This would return two rows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">SELECT</span> puppy_id</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">FROM</span> puppies</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb12-4" title="4">  age_yrs <span class="op">&lt;</span> <span class="fl">0.6</span>;</a></code></pre></div>
<p>Now we want to use the above statement as a subquery (inside parentheses) in another query. You’ll notice we’re using a <code>WHERE</code> clause with the <a href="http://www.postgresqltutorial.com/postgresql-in/">IN</a> operator to check if the <code>puppy_id</code> from the “friends” table meets the conditions in the subquery.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">SELECT</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">FROM</span> friends</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb13-4" title="4">  puppy_id <span class="kw">IN</span> (</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="kw">SELECT</span> puppy_id</a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="kw">FROM</span> puppies</a>
<a class="sourceLine" id="cb13-7" title="7">    <span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb13-8" title="8">      age_yrs <span class="op">&lt;</span> <span class="fl">0.6</span></a>
<a class="sourceLine" id="cb13-9" title="9">  );</a></code></pre></div>
<p>We should get just one row back. River Song has a puppy younger than 6 months old.</p>
<pre class="shell"><code> id | first_name | last_name | puppy_id
----+------------+-----------+----------
  5 | River      | Song      |        8
(1 row)</code></pre>
<h2 id="using-joins-vs.-subqueries">Using joins vs. subqueries</h2>
<p>We can use either a <code>JOIN</code> operation or a subquery to filter for the same information. Both methods can be used to get info from multiple tables. Take the query/subquery from above:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">SELECT</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="kw">FROM</span> friends</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb15-4" title="4">  puppy_id <span class="kw">IN</span>  (</a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="kw">SELECT</span> puppy_id</a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="kw">FROM</span> puppies</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb15-8" title="8">      age_yrs <span class="op">&lt;</span> <span class="fl">0.6</span></a>
<a class="sourceLine" id="cb15-9" title="9">  );</a></code></pre></div>
<p>Which produced the following result:</p>
<pre class="shell"><code> id | first_name | last_name | puppy_id
----+------------+-----------+----------
  5 | River      | Song      |        8
(1 row)</code></pre>
<p>Instead of using a <code>WHERE</code> clause with a subquery, we could use a <code>JOIN</code> operation:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">SELECT</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="kw">FROM</span> friends</a>
<a class="sourceLine" id="cb17-3" title="3"><span class="kw">INNER</span> <span class="kw">JOIN</span> puppies <span class="kw">ON</span> (puppies.puppy_id <span class="op">=</span> friends.puppy_id)</a>
<a class="sourceLine" id="cb17-4" title="4"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb17-5" title="5">  puppies.age_yrs <span class="op">&lt;</span> <span class="fl">0.6</span>;</a></code></pre></div>
<p>Again, we’d get back one result, but because we used an <code>INNER JOIN</code> we have information from both the “puppies” and “friends” tables.</p>
<pre class="shell"><code>id | first_name | last_name | puppy_id |  name  | age_yrs | breed  | weight_lbs | microchipped | puppy_id
----+------------+-----------+----------+--------+---------+--------+------------+--------------+----------
  5 | River      | Song      |        8 | Jaxson |     0.4 | Beagle |         19 | t            |        8
(1 row)</code></pre>
<h3 id="should-i-use-a-join-or-a-subquery">Should I use a JOIN or a subquery?</h3>
<p>As stated earlier, we could use either a JOIN operation or a subquery to filter for table rows. However, you might want to think about whether using a JOIN or a subquery is more appropriate for retrieving data.</p>
<p>A JOIN operation is ideal when you want to combine rows from one or more tables based on a match condition. Subqueries work great when you’re returning a single value. When you’re returning multiple rows, you could opt for a subquery or a JOIN.</p>
<p>Executing a query using a JOIN could potentially be faster than executing a subquery that would return the same data. (A subquery will execute once for each row returned in the outer query, whereas the <code>INNER JOIN</code> only has to make one pass through the data.) However, this isn’t always the case. Performance depends on the size of your data, what you’re filtering for, and how the server optimizes the query. With smaller datasets, the difference in performance of a JOIN and subquery is imperceptible. However, there are use cases where a subquery would improve performance.</p>
<p>(<em>See this article for more info: <a href="https://crate.io/a/sql-subquery-vs-left-join/">When is a SQL Subquery 260x Faster than a Left Join?</a></em>)</p>
<p>We can use the the <a href="http://www.postgresqltutorial.com/postgresql-explain/">EXPLAIN</a> statement to see runtime statistics of our queries that help with debugging slow queries. (We’ll get into this more later!)</p>
<h2 id="helpful-links-1">Helpful links:</h2>
<ul>
<li>PostgreSQL Tutorial: <a href="http://www.postgresqltutorial.com/postgresql-joins/">PostgreSQL Joins</a></li>
<li>PostgreSQL Tutorial: <a href="http://www.postgresqltutorial.com/postgresql-subquery/">PostgreSQL Subquery</a></li>
<li>PostgreSQL Docs: <a href="https://www.postgresql.org/docs/8.3/functions-subquery.html">Subquery Expressions</a></li>
<li>Essential SQL: <a href="https://www.essentialsql.com/what-is-the-difference-between-a-join-and-subquery/">Subqueries versus Joins</a></li>
<li>Essential SQL: <a href="https://www.essentialsql.com/get-ready-to-learn-sql-server-20-using-subqueries-in-the-select-statement/">Using Subqueries with the Select Statement</a></li>
</ul>
<hr />
<h1 id="postgresql-indexes">PostgreSQL Indexes</h1>
<p>PostgreSQL indexes can help us optimize our queries for faster performance. In this reading, we’ll learn how to create an index, when to use an index, and when to avoid using them.</p>
<h2 id="what-is-a-postgresql-index">What is a PostgreSQL index?</h2>
<p>A PostgreSQL index works like an index in the back of a book. It points to information contained elsewhere and can be a faster method of looking up the information we want.</p>
<p>A book index contains a list of references with page numbers. Instead of having to scan all the pages of the book to find the places where specific information appears, a reader can simply check the index. In similar fashion, PostgreSQL indexes, which are special lookup tables, let us make faster database queries.</p>
<p>Let’s say we had the following table:</p>
<table>
<thead>
<tr class="header">
<th>addresses</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>address_id</td>
</tr>
<tr class="even">
<td>address</td>
</tr>
<tr class="odd">
<td>address2</td>
</tr>
<tr class="even">
<td>city_id</td>
</tr>
<tr class="odd">
<td>postal_code</td>
</tr>
<tr class="even">
<td>phone_number</td>
</tr>
</tbody>
</table>
<p>And we made a query to the database like the following:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">SELECT</span> <span class="op">*</span> <span class="kw">FROM</span> addresses <span class="kw">WHERE</span> phone_number <span class="op">=</span> <span class="st">&#39;5556667777&#39;</span>;</a></code></pre></div>
<p>The above query would scan every row of the “addresses” table to find matching rows based on the given phone number. If “addresses” is a large table (let’s say with millions of entries), and we only expect to get a small number of results back (one row, or a few rows), then such a query would be an inefficient way to retrieve data. Instead of scanning every row, we could create an index for the phone column for faster data retrieval.</p>
<h2 id="how-to-create-an-index">How to create an index</h2>
<p>To create a <a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">PostgreSQL index</a>, use the following syntax:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> index_name <span class="kw">ON</span> table_name (column_name);</a></code></pre></div>
<p>We can create a phone number index for the above “addresses” table with the following:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> addresses_phone_index <span class="kw">ON</span> addresses (phone_number);</a></code></pre></div>
<p>You can delete an index using the <code>DROP INDEX</code> command:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">DROP</span> <span class="kw">INDEX</span> addresses_phone_index;</a></code></pre></div>
<p>After an index has been created, the system will take care of the rest – it will update an index when the table is modified and use the index in queries when it improves performance over a full table scan.</p>
<h3 id="types-of-indexes">Types of indexes</h3>
<p>PostgreSQL provides several index types: B-tree, Hash, GiST and GIN. The CREATE INDEX command creates B-tree indexes by default, which fit the most common situations. While it’s good to know other index types exist, you’ll probably find yourself using the default B-tree most often.</p>
<p><strong>Single-Column Indexes</strong> Uses only one table column.</p>
<p>Syntax:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> index_name <span class="kw">ON</span> table_name (column_name);</a></code></pre></div>
<p>Addresses Example:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> addresses_phone_index <span class="kw">ON</span> addresses (phone_number);</a></code></pre></div>
<p><strong>Multiple-Column Indexes</strong> Uses more than one table column.</p>
<p>Syntax:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> index_name <span class="kw">ON</span> table_name (col1_name, col2_name);</a></code></pre></div>
<p>Addresses Example:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> idx_addresses_city_post_code <span class="kw">ON</span> table_name (city_id, postal_code);</a></code></pre></div>
<p><strong>Partial Indexes</strong> Uses subset of a table defined by a conditional expression.</p>
<p>Syntax:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> index_name <span class="kw">ON</span> table_name <span class="kw">WHERE</span> (conditional_expression);</a></code></pre></div>
<p>Addresses Example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">CREATE</span> <span class="kw">INDEX</span> addresses_phone_index <span class="kw">ON</span> addresses (phone_number) <span class="kw">WHERE</span> (city_id <span class="op">=</span> <span class="dv">2</span>);</a></code></pre></div>
<h2 id="when-to-use-an-index">When to use an index</h2>
<p>Indexes are intended to enhance database performance and are generally thought to be a faster data retrieval method than a sequential (or row-by-row) table scan. However, there are instances where using an index would not improve efficiency, such as the following:</p>
<ul>
<li>When working with a relatively small table (i.e. not a lot of rows) * When a table has frequent, large-batch update or insert operations * When working with columns that contain many NULL values * When working with columns that are frequently manipulated</li>
</ul>
<p>An important thing to note about indexes is that, while they can optimize READ (i.e. table query) speed, they can also hamper WRITE (i.e. table updates/insertions) speed. The latter’s performance is affected due to the system having to spend time updating indexes whenever a change or insertion is made to the table.</p>
<p>The system optimizes database performance and decides whether to use an index in a query or to perform a sequential table scan, but we can analyze query performance ourselves to debug slow queries using <code>EXPLAIN</code> and <code>EXPLAIN ANALYZE</code>.</p>
<p>Here is an example of using <code>EXPLAIN</code> from the <a href="http://www.postgresqltutorial.com/postgresql-inner-join/">PostgreSQL docs</a>:</p>
<p>```sql EXPLAIN SELECT * FROM tenk1;</p>
<p>QUERY PLAN ————————————————————- Seq Scan on tenk1 (cost=0.00..458.00 rows=10000 width=244) ```</p>
<p>In the QUERY PLAN above, we can see that a sequential table scan (<code>Seq Scan</code>) was performed on the table called “tenk1”. In parentheses, we see performance information:</p>
<ul>
<li>Estimated start-up cost (or time expended before the scan can start): 0.00 * Estimated total cost: 458.00 * Estimated number of rows output: 10000 * Estimated average width (in bytes) of rows: 244</li>
</ul>
<p>It’s important to note that, although we might mistake the number next to <code>cost</code> for milliseconds, <code>cost</code> is not measured in any particular unit and is an arbitrary measurement relatively based on other query costs.</p>
<p>If we use the <code>ANALYZE</code> keyword after <code>EXPLAIN</code> on a <code>SELECT</code> statement, we can get more information about query performance:</p>
<p>```sql EXPLAIN ANALYZE SELECT * FROM tenk1 t1, tenk2 t2 WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;</p>
<p>QUERY PLAN ———————————————————————————————————————————- Nested Loop (cost=2.37..553.11 rows=106 width=488) (actual time=1.392..12.700 rows=100 loops=1) -&gt; Bitmap Heap Scan on tenk1 t1 (cost=2.37..232.35 rows=106 width=244) (actual time=0.878..2.367 rows=100 loops=1) Recheck Cond: (unique1 &lt; 100) -&gt; Bitmap Index Scan on tenk1_unique1 (cost=0.00..2.37 rows=106 width=0) (actual time=0.546..0.546 rows=100 loops=1) Index Cond: (unique1 &lt; 100) -&gt; Index Scan using tenk2_unique2 on tenk2 t2 (cost=0.00..3.01 rows=1 width=244) (actual time=0.067..0.078 rows=1 loops=100) Index Cond: (unique2 = t1.unique2) Total runtime: 14.452 ms ```</p>
<p>We can see in the QUERY PLAN above that there are other types of scans happening: Bitmap Heap Scan, Bitmap Index Scan, and Index Scan. We know that an index has been created, and the system is using it to scan for results instead of performing a sequential scan. At the bottom, we also have a total runtime of 14.42 ms, which is pretty fast.</p>
<h2 id="helpful-links-2">Helpful links:</h2>
<ul>
<li><a href="http://www.postgresqltutorial.com/postgresql-joins/">PostgreSQL docs: Indexes</a> * <a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">PostgreSQL docs: Performance Tips</a> * <a href="http://www.postgresqltutorial.com/postgresql-in/">Heroku DevCenter: Efficient Use of PostgreSQL Indexes</a></li>
</ul>
<h2 id="what-we-learned-1">What we learned:</h2>
<ul>
<li>How to create a PostgreSQL index * Types of indexes * Use cases for indexes and when to avoid them * How to use <code>EXPLAIN</code> to analyze query performance</li>
</ul>
<p><a href="https://www.postgresql.org/docs/8.3/tutorial-join.html">1</a>: https://www.postgresql.org/docs/9.1/sql-createindex.html <a href="http://www.postgresqltutorial.com/postgresql-inner-join/">2</a>: https://www.postgresql.org/docs/9.1/using-explain.html <a href="http://www.postgresqltutorial.com/postgresql-joins/">3</a>: https://www.postgresql.org/docs/9.1/indexes.html <a href="https://www.postgresql.org/docs/8.2/functions-aggregate.html">4</a>: https://www.postgresql.org/docs/8.1/performance-tips.html <a href="http://www.postgresqltutorial.com/postgresql-in/">5</a>: https://devcenter.heroku.com/articles/postgresql-indexes</p>
<hr />
<h1 id="node-postgres-and-prepared-statements">Node-Postgres And Prepared Statements</h1>
<p>The library [node-postgres] is, not too surprisingly, the library that Node.js applications use to connect to a database managed by a PostgreSQL RDBMS. The applications that you deal with will use this library to make connections to the database and get rows returned from your SQL <code>SELECT</code> statements.</p>
<h2 id="connecting">Connecting</h2>
<p>The <strong>node-postgres</strong> library provides two ways to connect to it. You can use a single <code>Client</code> object, or you can use a <code>Pool</code> of <code>Client</code> objects. Normally, you want to use a <code>Pool</code> because creating and opening single connections to any database server is a “costly” operation in terms of CPU and network resources. A <code>Pool</code> creates a group of those <code>Client</code> connections and lets your code use them whenever it needs to.</p>
<p>To use a <code>Pool</code>, you specify any specific portions of the following connection parameters that you need. The default values for each parameter is listed with each parameter.</p>
<div class="line-block">Connection parameter | What it indicates | Default value | |———————-|———————————————|—————————————–| | user | The name of the user you want to connect as | The user name that runs the application | | password | The password to use | The password set in your configuration | | database | The name of the database to connect to | The user’s database | | port | The port over which to connect | 5432 | | host | The name of the server to connect to | localhost |</div>
<p>Normally, you will only override the user and password fields, and sometimes the database if it doesn’t match the user’s name. You do that by instantiating a new <code>Pool</code> object and passing in an object with those key/value pairs.</p>
<p>```js const { Pool } = require(‘pg’);</p>
<p>const pool = new Pool({ user: ‘application_user’, password: ‘iy7qTEcZ’, }); ```</p>
<p>Once you have an instance of the <code>Pool</code> class, you can use the <code>query</code> method on it to run queries. (The <code>query</code> method returns a Promise, so it’s nice to just use <code>await</code> for it to finish.)</p>
<p>``<code>js const results = await pool.query(</code> SELECT id, name, age_yrs FROM puppies; `);</p>
<p>console.log(results); ```</p>
<p>When this runs, you will get an object that contains a property named “rows”. The value of “rows” will be an array of the rows that match the statement. Here’s an example output from the code above.</p>
<p><code>{ rows: [ { id: 1, name: 'Cooper', age_yrs: '1.0' }, { id: 2, name: 'Indie', age_yrs: '0.5' }, { id: 3, name: 'Kota', age_yrs: '0.7' }, { id: 4, name: 'Zoe', age_yrs: '0.8' }, { id: 5, name: 'Charley', age_yrs: '1.5' }, { id: 6, name: 'Ladybird', age_yrs: '0.6' }, { id: 7, name: 'Callie', age_yrs: '0.9' }, { id: 8, name: 'Jaxson', age_yrs: '0.4' }, { id: 9, name: 'Leinni', age_yrs: '1.0' }, { id: 10, name: 'Max', age_yrs: '1.6' } ], }</code></p>
<p>You can see that the “rows” property contains an array of objects. Each object represents a row in the “puppies” table that matches the query. Each object has a property named after the column selected in the <code>SELECT</code> statement. The query read <code>SELECT id, name, age_yrs</code> and each object has an “id”, “name”, and an “age_yrs” property.</p>
<p>You can then use that array to loop over and do things with it. For example, you could print them to the console like this:</p>
<p><code>js for (let row of results.rows) { console.log(`${row.id}: ${row.name} is ${row.age_yrs} old&lt;/li&gt;`); }</code></p>
<p>Which would show</p>
<p><code>1. Cooper is 1.0 years old 2. Indie is 0.5 years old 3. Kots is 0.7 years old ...</code></p>
<h2 id="prepared-statement">Prepared Statement</h2>
<p>Prepared statements are SQL statements that have parameters in them that you can use to substitute values. The parameters are normally part of the <code>WHERE</code> clause in all statements. You will also use then in the <code>SET</code> portion of <code>UPDATE</code> statements and the <code>VALUES</code> portion of <code>INSERT</code> statements.</p>
<p>For example, say your application collected the information to create a new row in the puppy table by asking for the puppy’s name, age, breed, weight, and if it was microchipped. You’d have those values stored in variables somewhere. You’d want to create an <code>INSERT</code> statement that inserts the data from those variables into a SQL statement that the RDBMS could then execute to insert a new row.</p>
<p>Think about what a generic <code>INSERT</code> statement would look like. It would have to have the</p>
<p><code>sql INSERT INTO puppies (name, age_yrs, breed, weight_lbs, microchipped)</code></p>
<p>portion of the statement. The part that would change with each time you inserted would be the specific values that would go into the <code>VALUES</code> section of the <code>INSERT</code> statement. With prepared statements, you use <em>positional parameters</em> to act as placeholders for the actual values that you will provide the query.</p>
<p>For example, the generic <code>INSERT</code> statement from above would look like this.</p>
<p><code>sql INSERT INTO puppies (name, age_yrs, breed, weight_lbs, microchipped) VALUES ($1, $2, $3, $4, $5);</code></p>
<p>Each of the “$” placeholders is a positional argument for the parameters that you pass in. That means, the value that pass in for the first parameter will be put where the “$1” placeholder is, which is the value for the “name” of the puppy. The “$2” corresponds to the “age_yrs” column, so it should contain the age of the puppy. This continues for the third, fourth, and fifth parameters, as well.</p>
<p>Assume that in your code, you have the variables <code>name</code>, <code>age</code>, <code>breedName</code>, <code>weight</code>, and <code>isMicrochipped</code> containing the values that the user provided for the new puppy. Then, your use of the <code>query</code> method will now include another argument, the values that you want to pass in inside an array.</p>
<p><code>js await pool.query(` INSERT INTO puppies (name, age_yrs, breed, weight_lbs, microchipped) VALUES ($1, $2, $3, $4, $5); `, [name, age, breedName, weight, isMicrochipped]);</code></p>
<p>You can see that the variable <code>name</code> is in the first position of the array, so it will be substituted into the placeholder “$1”. The <code>age</code> variable is in the second position of the array, so it will be substituted into the “$2” placeholder.</p>
<p>The full documentation for how to use queries with <strong>node-postgres</strong> can be found on the [Queries] documentation page on their Web site.</p>
<h2 id="try-it-out-for-yourself">Try it out for yourself</h2>
<p>Make sure you have a database with a table that has data in it. If you don’t, create a new database and run the following SQL.</p>
<p>```sql CREATE TABLE puppies ( id SERIAL PRIMARY KEY, name VARCHAR(50) NOT NULL, age_yrs NUMERIC(3,1) NOT NULL, breed VARCHAR(100) NOT NULL, weight_lbs INTEGER NOT NULL, microchipped BOOLEAN NOT NULL DEFAULT FALSE );</p>
<p>insert into puppies(name, age_yrs, breed, weight_lbs, microchipped) values (‘Cooper’, 1, ‘Miniature Schnauzer’, 18, ‘yes’), (‘Indie’, 0.5, ‘Yorkshire Terrier’, 13, ‘yes’), (‘Kota’, 0.7, ‘Australian Shepherd’, 26, ‘no’), (‘Zoe’, 0.8, ‘Korean Jindo’, 32, ‘yes’), (‘Charley’, 1.5, ‘Basset Hound’, 25, ‘no’), (‘Ladybird’, 0.6, ‘Labradoodle’, 20, ‘yes’), (‘Callie’, 0.9, ‘Corgi’, 16, ‘no’), (‘Jaxson’, 0.4, ‘Beagle’, 19, ‘yes’), (‘Leinni’, 1, ‘Miniature Schnauzer’, 25, ‘yes’ ), (‘Max’, 1.6, ‘German Shepherd’, 65, ‘no’); ```</p>
<p>Now that you have ten rows in the “puppies” table of a database, you can create a simple Node.js project to access it.</p>
<p>Create a new directory somewhere that’s not part of an existing project. Run <code>npm init -y</code> to initialize the <strong>package.json</strong> file. Then, run <code>npm install pg</code> to install the library from this section. (Why is the name of the library “node-postgres” but you install “pg”? Dunno.) Finally, open Visual Studio Code for the current directory with <code>code .</code>.</p>
<p>Create a new file named <strong>sql-test.js</strong>.</p>
<p>The first thing you need to do is import the <code>Pool</code> class from the <strong>node-postgres</strong> library. The name of the library in the <strong>node_modules</strong> directory is “pg”. That line of code looks like this and can be found all over the [node-postgres] documentation.</p>
<p><code>js const { Pool } = require('pg');</code></p>
<p>Now, write some SQL that will select all of the records from the “puppies” table. (This is assuming you want to select puppies. If you’re using a different table with different data, write the appropriate SQL here.)</p>
<p>```js const { Pool } = require(‘pg’);</p>
<p>const allPuppies = <code>SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies;</code>; ```</p>
<p>You will now use that with a new <code>Pool</code> object. You will need to know the name of the database that the “puppies” table is in (or whatever database you want to connect to).</p>
<p>```js const { Pool } = require(‘pg’);</p>
<p>const allPuppies = <code>SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies;</code>;</p>
<p>const pool = new Pool({ database: ‘«database name»’ }); ```</p>
<p>Of course, replace “«database name»” with the name of your database. Otherwise, when you run it, you will see this error message.</p>
<p><code>UnhandledPromiseRejectionWarning: error: database "«database name»" does not exist</code></p>
<p>This will, by default, connect to “localhost” on port “5432” with your user credentials because you did not specify any other parameters.</p>
<p>Once you have the pool, you can execute the query that you have in <code>allPuppies</code>. Remember that the <code>query</code> method returns a Promise. This code wraps the call to <code>query</code> in an <code>async function</code> so that it can use the <code>await</code> keyword for simplicity’s sake. Then, it prints out the rows that it fetched to the console. Finally, it calls <code>end</code> on the connection pool object to tell <strong>node-postgres</strong> to close all the connections and quit. Otherwise, your application will just hang and you’ll have to close it with Control+C.</p>
<p>```js const { Pool } = require(‘pg’);</p>
<p>const allPuppiesSql = <code>SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies;</code>;</p>
<p>const pool = new Pool({ database: ‘«database name»’ });</p>
<p>async function selectAllPuppies() { const results = await pool.query(allPuppiesSql); console.log(results.rows); pool.end(); }</p>
<p>selectAllPuppies(); ```</p>
<p>When you run this with <code>node sql-test.js</code>, you should see some output like this although likely in a nicer format.</p>
<p><code>[ { id: 1, name: 'Cooper', age_yrs: '1.0', breed: 'Miniature Schnauzer', weight_lbs: 18, microchipped: true }, { id: 2, name: 'Indie', age_yrs: '0.5', breed: 'Yorkshire Terrier', weight_lbs: 13, microchipped: true }, { id: 3, name: 'Kota', age_yrs: '0.7', breed: 'Australian Shepherd', weight_lbs: 26, microchipped: false }, { id: 4, name: 'Zoe', age_yrs: '0.8', breed: 'Korean Jindo', weight_lbs: 32, microchipped: true }, { id: 5, name: 'Charley', age_yrs: '1.5', breed: 'Basset Hound', weight_lbs: 25, microchipped: false }, { id: 6, name: 'Ladybird', age_yrs: '0.6', breed: 'Labradoodle', weight_lbs: 20, microchipped: true }, { id: 7, name: 'Callie', age_yrs: '0.9', breed: 'Corgi', weight_lbs: 16, microchipped: false }, { id: 8, name: 'Jaxson', age_yrs: '0.4', breed: 'Beagle', weight_lbs: 19, microchipped: true }, { id: 9, name: 'Leinni', age_yrs: '1.0', breed: 'Miniature Schnauzer', weight_lbs: 25, microchipped: true }, { id: 10, name: 'Max', age_yrs: '1.6', breed: 'German Shepherd', weight_lbs: 65, microchipped: false } ]</code></p>
<p>Now, try one of those parameterized queries. Comment out the <code>selectAllPuppies</code> function and invocation.</p>
<p>```js // async function selectAllPuppies() { // const results = await pool.query(allPuppiesSql); // console.log(results.rows); // pool.end(); // }</p>
<p>// selectAllPuppies(); ```</p>
<p>Add the following content to the bottom of the file.</p>
<p>``<code>js // Define the parameterized query where it will select a puppy // based on an id const singlePuppySql =</code> SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies WHERE ID = $1; `;</p>
<p>// Run the parameterized SQL by passing in an array that contains // the puppyId to the query method. Then, print the results and // end the pool. async function selectOnePuppy(puppyId) { const results = await pool.query(singlePuppySql, [puppyId]); console.log(results.rows); pool.end(); }</p>
<p>// Get the id from the command line and store it // in the variable “id”. Pass that value to the // selectOnePuppy function. const id = Number.parseInt(process.argv<a href="http://www.postgresqltutorial.com/postgresql-inner-join/">2</a>); selectOnePuppy(id); ```</p>
<p>Now, when you run the program, include a number after the command. For example, if you run <code>node sql-test.js 1</code>, it will print out</p>
<p><code>[ { id: 1, name: 'Cooper', age_yrs: '1.0', breed: 'Miniature Schnauzer', weight_lbs: 18, microchipped: true } ]</code></p>
<p>If you run <code>node sql-test.js 4</code>, it will print out</p>
<p><code>[ { id: 4, name: 'Zoe', age_yrs: '0.8', breed: 'Korean Jindo', weight_lbs: 32, microchipped: true } ]</code></p>
<p>That’s because the number that you type on the command line is being substituted in for the “$1” in the parameterized query. That means, when you pass in “4”, It’s like the RDMBS takes the parameterized query</p>
<p><code>sql SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies WHERE ID = $1;</code></p>
<p>and your value “4”</p>
<p>and mushes them together to make</p>
<p><code>sql SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies WHERE ID = 4; -- Value substituted here by PostgreSQL.</code></p>
<p>That happens because when you run the query, you call the <code>query</code> method like this.</p>
<p><code>js await pool.query(singlePuppySql, [puppyId]);</code></p>
<p>which passes along the sql stored in <code>singlePuppySql</code> and the value stored in <code>puppyId</code> (as the first parameter) to PostgreSQL.</p>
<p>What do you think will happen if you change <code>singlePuppySql</code> to have <em>two</em> parameters instead of one, but only pass in one parameter through the <code>query</code> method?</p>
<p><code>js const singlePuppySql = ` SELECT id, name, age_yrs, breed, weight_lbs, microchipped FROM puppies WHERE ID = $1 AND age_yrs &gt; $2; `;</code></p>
<p>PostgreSQL is smart enough to see that you’ve only provided one parameter value but it needs <em>two</em> positional parameters. It gives you the error message</p>
<p><code>error: bind message supplies 1 parameters, but prepared statement "" requires 2</code></p>
<p>In this error message, the term “bind message” is the kind of message that the <code>query</code> method sends to PostgreSQL when you provide parameters to it.</p>
<p>Change the query back to how it was. Now, add an extra parameter to the invocation of the <code>query</code> method. What do you think will</p>
<p><code>js await pool.query(singlePuppySql, [puppyId, 'extra parameter']);</code></p>
<p>Again, PostgreSQL gives you an error message about a mismatch in the number of placeholders in the SQL and the number of values you passed to it.</p>
<p><code>error: bind message supplies 2 parameters, but prepared statement "" requires 1</code></p>
<h2 id="what-youve-learned">What you’ve learned</h2>
<p>Here, you’ve seen how to connect to a PostgreSQL database using the <strong>node-postgres</strong> library named “pg”. You saw how to run simple SQL statements against it and handle the results. You also saw how to create parameterized queries so that you can pass in values to be substituted.</p>
<p>If you are using the <strong>node-postgres</strong> library and running your own handcrafted SQL, you will most often use parameterized queries. It’s good to get familiar with them.</p>
<p>[node-postgres]: https://www.node-postgres.com [Queries]: https://node-postgres.com/features/queries</p>
<hr />
<h1 id="transactions-with-sequelize">Transactions With Sequelize</h1>
<p>In this reading, we will learn about database <em>transactions</em> and how we use them via Sequelize. We will learn how to group multiple update operations into a single atomic, indivisible unit.</p>
<p>At the end of the reading, you should know:</p>
<ol type="1">
<li>How to write code that is resilient to SQL operation failures, 1. How to group multiple operations into a database transaction using Sequelize (the <code>sequelize.transaction</code> method), 1. How to prevent “race conditions” using transactions.</li>
</ol>
<h2 id="the-problem-database-updates-can-fail">The Problem: Database Updates Can Fail</h2>
<p>Imagine a scenario with a banking database. Markov wants to transfer $7,500 to Curie. To perform the transfer, we will perform two database update operations:</p>
<ol type="1">
<li>Reduce Markov’s account balance by $7,500, 2. Increase Curie’s account balance by $7,500.</li>
</ol>
<p>When transferring money, it’s very important that <em>both</em> operations be performed. If we reduce Markov’s balance but fail to increase Curie’s balance, the bank effectively steals money from Markov. If we increase Curie’s balance without reducing Markov’s balance, the bank effectively gives away free money to Curie. Neither is acceptable.</p>
<p>We must keep in mind that any attempt to perform a database update can sometimes <em>fail</em>. It can fail for a number of reasons:</p>
<ol type="1">
<li>The command is sent, but the database has previously been shut down by the database administrator. Because the database is not running, the database is not listening for our update, won’t receive it, and thus won’t process it. 2. A bug in the database or operating system software has caused the database or operating system to crash. Again, the database is not running, so it can neither receive nor process our update. 3. Power has been lost to the machine running the database. The database is not running. 4. The internet connection that connects us to the database machine is disrupted. The database may be running and listening for SQL requests to process. However, our update request cannot get through to the database machine. Because the database cannot receive our request, the database cannot process it. 5. The update asks the database to violate a pre-defined constraint. For example: the database may have a constraint that an account balance must never be less than zero. Any update that asks the database to reduce an account balance to less than zero will be rejected and therefore fail.</li>
</ol>
<p>Only this last scenario is “our fault.” The fact is that database updates can fail <strong>through no fault of our own</strong>. With regard to our example: our first SQL request to reduce Markov’s account balance may succeed, but the database may then crash before we have sent the request to increase Curie’s balance. Through no fault of our own, the bank has stolen money from Markov without giving it to Curie.</p>
<p>How can we write code that avoids this fundamental problem?</p>
<h2 id="the-solution-database-transactions">The Solution: Database Transactions</h2>
<p>One way to solve the problem is to “group” or “pair” the two update operations somehow. We want to tell the database “Reduce Markov’s balance AND increment Curie’s balance.” We want to tell the database: “If for any reason you cannot perform <strong>both</strong> operations, make sure not to perform <strong>either</strong>.” We want to tell the database: “If you crash after reducing Markov’s balance, make sure to either (a) increase Curie’s balance when you restart, or (b) undo the increase to Markov’s balance when you restart.”</p>
<p>We want to ask the database to treat the pair of updates as one <em>atomic</em> (meaning <strong>indivisible</strong>) unit. SQL lets you do this using a feature called <em>transactions</em>.</p>
<p>You’ve previously seen how to use SQL transactions:</p>
<p><code>sql START TRANSACTION; -- Reduce Markov's balance by $7500 UPDATE "BankAccounts" SET balance = balance - 7500 WHERE id = 1; -- Increment Curie's balance by $7500 UPDATE "BankAccounts" SET balance = balance + 7500 WHERE id = 2; COMMIT TRANSACTION;</code></p>
<p>SQL guarantees to you that everything between <code>START TRANSACTION</code> and <code>COMMIT TRANSACTION</code> will be processed <em>atomically</em>. If any update operation fails, none of the updates will be performed. The transaction is “all-or-nothing.”</p>
<p>In this reading you will learn how to use SQL transactions with the Sequelize ORM.</p>
<h2 id="the-bankaccounts-schema">The <code>BankAccounts</code> Schema</h2>
<p>For our example in this reading, I will use a single table with two accounts.</p>
<p><code>catsdb=&gt; SELECT * FROM "BankAccounts"; id | clientName | balance | ... ----+------------+---------+----- 1 | Markov | 5000 | ... 2 | Curie | 10000 | ... (2 rows)</code></p>
<p>I have generated a Sequelize model corresponding to the <code>BankAccounts</code> table:</p>
<p>```javascript // ./models/bank_account.js ‘use strict’; module.exports = (sequelize, DataTypes) =&gt; { // Define BankAccount model. const BankAccount = sequelize.define(‘BankAccount’, { // Define clientName attribute. clientName: { type: DataTypes.STRING, allowNull: false, // Define validations on clientName. validate: { // clientName must not be null. notNull: { msg: “clientName must not be NULL”, }, // clientName must not be empty. notEmpty: { msg: “clientName must not be empty”, }, }, },</p>
<p>// Define balance attribute. balance: { type: DataTypes.INTEGER, allowNull: false, // Define validations on balance. validate: { // balance must not be less than zero. min: { args: [0], msg: “balance must not be less than zero”, }, }, }, }, {});</p>
<p>return BankAccount; }; ```</p>
<p>Notice that the <code>min</code> validation on <code>balance</code> will not allow us to save an account balance that is below zero.</p>
<h2 id="example-an-update-fails-because-of-validation-failure">Example: An Update Fails Because Of Validation Failure</h2>
<p>Let’s imagine that Markov wants to transfer $7,500 to Curie. Unfortunately, Markov has only $5,000 in his account! Decrementing Markov’s account balance by $7,500 would put it in the negative, which our validation will not allow. Thus the transfer must fail.</p>
<p>Imagine that Markov is unaware that his account balance cannot cover the transfer. He tries to perform the transfer anyway:</p>
<p>```javascript // ./index.js const { sequelize , BankAccount } = require(“./models”);</p>
<p>// This code will try to transfer $7,500 from Markov to Curie. async function main() { // Fetch Markov and Curie’s accounts. const markovAccount = await BankAccount.findByPk(1); const curieAccount = await BankAccount.findByPk(2);</p>
<p>try { // Increment Curie’s balance by $7,500. curieAccount.balance += 7500; await curieAccount.save();</p>
<p>// Decrement Markov’s balance by $7,500. markovAccount.balance -= 7500; await markovAccount.save(); } catch (err) { // Report if anything goes wrong. console.log(“Error!”);</p>
<p>for (const e of err.errors) { console.log( <code>${e.instance.clientName}: ${e.message}</code> ); } }</p>
<p>await sequelize.close(); }</p>
<p>main(); ```</p>
<p>Running this code prints the following:</p>
<p><code>Executing (default): SELECT "id", "clientName", "balance", "createdAt", "updatedAt" FROM "BankAccounts" AS "BankAccount" WHERE "BankAccount"."id" = 1; Executing (default): SELECT "id", "clientName", "balance", "createdAt", "updatedAt" FROM "BankAccounts" AS "BankAccount" WHERE "BankAccount"."id" = 2; Executing (default): UPDATE "BankAccounts" SET "balance"=$1,"updatedAt"=$2 WHERE "id" = $3 Error! Markov: balance must not be less than zero</code></p>
<p>Everything starts out fine. We fetch Markov and Curie’s accounts. We increase Curie’s balance. But then we hit a snag: when we call <code>markovAccount.save()</code>, Sequelize detects that we are trying to set Markov’s balance below zero. Sequelize therefore <strong>does not</strong> send a SQL request to update Markov’s account balance. Instead, <code>markovAccount.save()</code> throws an exception. We print the error: Markov’s balance must not be less than zero.</p>
<p>We thus avoid saving a negative balance for Markov. But other damage has already been done. If we now check account balances, we will see:</p>
<p><code>catsdb=&gt; SELECT * FROM "BankAccounts"; id | clientName | balance | ... ----+------------+---------+----- 1 | Markov | 5000 | ... 2 | Curie | 17500 | ... (2 rows)</code></p>
<p>The bank has given free money to Curie! We should have “rolledback” the increase of Curie’s balance. We will learn how to do that!</p>
<h2 id="incorrect-solutions">Incorrect Solutions</h2>
<p>One may suggest a fix: make sure to decrement Markov’s account balance before incrementing Curie’s balance! If Markov’s balance is insufficient, we can stop the transfer before giving Curie any money.</p>
<p>We <em>could</em> swap the order of the updates, and it would indeed fix this specific problem. But imagine if Markov tries to transfer $2,500 (an amount he can afford). We first decrement Markov’s account balance and then – the operating system crashes before the second update can be submitted. Curie’s balance is not incremented. The bank has stolen Markov’s money!</p>
<p>The problem is fundamental: no matter what order we perform the two updates in, the database can always fail <em>after</em> processing the first, but <em>before</em> processing the second. For our code to be resilient to unavoidable failures, there is no other choice but to use a database transaction.</p>
<h2 id="using-a-database-transaction-with-sequelize">Using A Database Transaction With Sequelize</h2>
<p>Let’s return to our previous example of trying to transfer $7,500 from Markov to Curie. Specifically, we will rewrite this key part:</p>
<p>```javascript // Increment Curie’s balance by $7,500. curieAccount.balance += 7500; await curieAccount.save();</p>
<p>// Decrement Markov’s balance by $7,500. markovAccount.balance -= 7500; await markovAccount.save(); ```</p>
<p>To ask Sequelize to perform the two updates in a SQL database transaction, we use the <code>sequelize.transaction</code> method. We will write this like so, instead:</p>
<p>```javascript await sequelize.transaction(async (tx) =&gt; { // Increment Curie’s balance by $7,500. curieAccount.balance += 7500; await curieAccount.save({ transaction: tx });</p>
<p>// Decrement Markov’s balance by $7,500. markovAccount.balance -= 7500; await markovAccount.save({ transaction: tx }); }); ```</p>
<p>Let’s go through the transaction code and explain each part:</p>
<p>``<code>javascript // Start a transaction. Queries run inside the callback can be part of // the transaction. await sequelize.transaction(async (tx) =&gt; { // Increment Curie's balance by $7,500. curieAccount.balance += 7500; // Pass the</code>tx` transaction object so that Sequelize knows to // update Curie’s account as part of this transaction (rather than // “on its own” per usual). await curieAccount.save({ transaction: tx });</p>
<p>// Decrement Markov’s balance by $7,500. markovAccount.balance -= 7500; // Again, pass the <code>tx</code> transaction object. Thus both updates are part // of the same transaction. await markovAccount.save({ transaction: tx });</p>
<p>// If no exceptions have been thrown, <code>sequelize.transaction</code> will // <code>COMMIT</code> the transaction after the end of the callback. // // If any error gets thrown, <code>sequelize.transaction</code> will abort // the transaction by issuing a <code>ROLLBACK</code>. This will cancel all // updates. }); ```</p>
<p>Let’s put the transaction code back into our original program:</p>
<p>```javascript // ./index.js const { sequelize, BankAccount } = require(“./models”);</p>
<p>async function main() { // Fetch Markov and Curie’s accounts. const markovAccount = await BankAccount.findByPk(1); const curieAccount = await BankAccount.findByPk(2);</p>
<p>try { await sequelize.transaction(async (tx) =&gt; { // Increment Curie’s balance by $7,500. curieAccount.balance += 7500; await curieAccount.save({ transaction: tx });</p>
<p>// Decrement Markov’s balance by $7,500. markovAccount.balance -= 7500; await markovAccount.save({ transaction: tx }); }); } catch (err) { // Report if anything goes wrong. console.log(“Error!”);</p>
<p>for (const e of err.errors) { console.log( <code>${e.instance.clientName}: ${e.message}</code> ); } }</p>
<p>await sequelize.close(); }</p>
<p>main(); ```</p>
<p>Running this code prints:</p>
<p><code>Executing (default): SELECT "id", "clientName", "balance", "createdAt", "updatedAt" FROM "BankAccounts" AS "BankAccount" WHERE "BankAccount"."id" = 1; Executing (default): SELECT "id", "clientName", "balance", "createdAt", "updatedAt" FROM "BankAccounts" AS "BankAccount" WHERE "BankAccount"."id" = 2; Executing (208b3951-9ab9-489b-97f0-afb49aaff807): START TRANSACTION; Executing (208b3951-9ab9-489b-97f0-afb49aaff807): UPDATE "BankAccounts" SET "balance"=$1,"updatedAt"=$2 WHERE "id" = $3 Executing (208b3951-9ab9-489b-97f0-afb49aaff807): ROLLBACK; Error! Markov: balance must not be less than zero</code></p>
<p>Let’s review what happened. We again start by fetching both <code>BankAccount</code>s. We next <code>START TRANSACTION</code>. We issue the update to Curie’s account.</p>
<p>Then Sequelize detects the validation failure when trying to run <code>markovAccount.save({ transaction: tx })</code>. Markov doesn’t have enough money in his account! Sequelize throws an exception. The <code>sequelize.transaction</code> method <em>catches the exception</em> and issues a <code>ROLLBACK</code> for the transaction. This tells the database to undo the prior increment of Curie’s account balance.</p>
<p>Having rolled back the transaction, the <code>sequelize.transaction</code> method <em>rethrows</em> the error, so that our logging code gets a chance to learn about the error and print its details.</p>
<h2 id="aside-what-is-the-transaction-object">Aside: What Is The <code>Transaction</code> Object?</h2>
<p><em>This is bonus information in case you are troubled by what the <code>tx</code> parameter to <code>sequelize.transaction</code> is for. You can use transactions correctly without knowing this bonus information.</em></p>
<p>What is the mysterious <code>tx</code> that is passed by <code>sequelize.transaction</code> to our callback? It is basically just a unique ID. In this case, the ID is: <code>208b3951-9ab9-489b-97f0-afb49aaff807</code>. You can see this ID in the logs above.</p>
<p>When we say <code>curieAccount.save({ transaction: tx })</code>, we are telling Sequelize: “update Curie’s account as part of transaction number <code>208b3951-9ab9-489b-97f0-afb49aaff807</code>.”</p>
<p>Sequelize needs transaction IDs because it can be running many SQL transactions <em>concurrently</em> (loosely speaking: “in parallel”). One part of the application could be transferring money from Markov to Curie at the same time another part of the application is transferring money from Kate to Ned.</p>
<p>If Sequelize did not keep track of transaction IDs, it would not know that <code>curieAccount.save()</code> should be a part of the Markov/Curie transaction rather than the Kate/Ned transaction.</p>
<h2 id="transactions-prevent-race-conditions">Transactions Prevent <em>Race Conditions</em></h2>
<p>There is still a subtle mistake in my bank transfer code. There is a potential problem if someone modifies Markov’s or Curie’s account in between (1) the initial fetch of their accounts, and (2) the transaction to update the accounts.</p>
<p>```javascript // ./index.js async function main() { // I will transfer only $5,000 so that Markov’s balance can cover the // amount. Markov starts out with $5,000.</p>
<p>// Fetch Markov and Curie’s accounts. const markovAccount = await BankAccount.findByPk(1); const curieAccount = await BankAccount.findByPk(2);</p>
<p>// *** // Imagine that right now some other program transfers the $5,000 out // of Markov’s account. Markov’s true account <strong>in the database</strong> now // has a balance of $0. But <code>markovAccount.balance</code> is still $5,000, // because we fetched Markov’s <code>BankAccount</code> <strong>before</strong> the transfer // was made! // ***</p>
<p>try { await sequelize.transaction(async (tx) =&gt; { // Increment Curie’s balance by $5,000 (to $15,000). curieAccount.balance += 5000; await curieAccount.save({ transaction: tx });</p>
<p>// Decrement <code>markovAccount.balance</code> by $5,000. // <code>markovAccount.balance</code> is set to zero. markovAccount.balance -= 5000; // Save and set Markov’s balance to zero. await markovAccount.save({ transaction: tx });</p>
<p>// Problem: Markov’s balance in the database was <em>already</em> zero. // Markov had no money to transfer. He should not have been able // to transfer the $5,000. }); } catch (err) { // … }</p>
<p>await sequelize.close(); }</p>
<p>main(); ```</p>
<p>Because another program can “race in between” (1) the reading of the account balances and (2) the updating of the balances, we call this potential problem a <em>race condition</em>. The easiest way to fix the race condition is to prohibit anyone else from modifying Markov’s account balance in between (1) and (2).</p>
<p>Luckily, the solution is simple. Any data used in a transaction will be <em>locked</em> until the transaction completes. Data that is locked can be neither read nor written by other transactions. If our transaction reads (or writes) data, no one else can read or write that data until our transaction completes. When we <code>COMMIT</code> (or <code>ROLLBACK</code>) all the locked data is freed (the locks are <em>released</em>).</p>
<p>We don’t have to lock the data ourselves. Simply by doing all our queries inside the same transaction, the database will lock the data for us. Therefore, to fix the problem, we should move the initial account fetching by <code>findByPk</code> into the transaction (i.e., pass it <code>{ transaction: tx }</code>):</p>
<p>```javascript async function main() { try { // Do all database access within the transaction. await sequelize.transaction(async (tx) =&gt; { // Fetch Markov and Curie’s accounts. const markovAccount = await BankAccount.findByPk( 1, { transaction: tx }, ); const curieAccount = await BankAccount.findByPk( 2, { transaction: tx } );</p>
<p>// No one can mess with Markov or Curie’s accounts until the // transaction completes! The account data has been locked!</p>
<p>// Increment Curie’s balance by $5,000. curieAccount.balance += 5000; await curieAccount.save({ transaction: tx });</p>
<p>// Decrement Markov’s balance by $5,000. markovAccount.balance -= 5000; await markovAccount.save({ transaction: tx }); }); } catch (err) { // … }</p>
<p>await sequelize.close(); }</p>
<p>main(); ```</p>
<p>This prints:</p>
<p><code>Executing (76321a03-93c5-47c0-861a-cf24c3e6f3bf): START TRANSACTION; Executing (76321a03-93c5-47c0-861a-cf24c3e6f3bf): SELECT "id", "clientName", "balance", "createdAt", "updatedAt" FROM "BankAccounts" AS "BankAccount" WHERE "BankAccount"."id" = 1; Executing (76321a03-93c5-47c0-861a-cf24c3e6f3bf): SELECT "id", "clientName", "balance", "createdAt", "updatedAt" FROM "BankAccounts" AS "BankAccount" WHERE "BankAccount"."id" = 2; Executing (76321a03-93c5-47c0-861a-cf24c3e6f3bf): UPDATE "BankAccounts" SET "balance"=$1,"updatedAt"=$2 WHERE "id" = $3 Executing (76321a03-93c5-47c0-861a-cf24c3e6f3bf): UPDATE "BankAccounts" SET "balance"=$1,"updatedAt"=$2 WHERE "id" = $3 Executing (76321a03-93c5-47c0-861a-cf24c3e6f3bf): COMMIT;</code></p>
<p>Notice that now <em>everything</em> is done in the transaction <code>76321a03-93c5-47c0-861a-cf24c3e6f3bf</code>. This includes the initial fetching of the accounts. Because the fetching is done within the transaction, other users are not allowed to modify the accounts until the transaction is finished.</p>
<p>Moving our read operations into the transaction has solved our race condition problem. Every Sequelize operation - whether reading or writing - can take a <code>transaction: tx</code> option. This includes:</p>
<ol type="1">
<li><code>findByPk</code> 1. <code>findAll</code> 1. <code>save</code> 1. <code>create</code> 1. <code>destroy</code></li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>Having completed this reading, here are the important things to take away:</p>
<ol type="1">
<li>You should know that any SQL update operation may fail, often through no fault of your own. 1. You should know that you must write code resilient to SQL failures. 1. You should know that when performing multiple update operations as part of a group, you must use a transaction. 1. You should know how to use <code>sequelize.transaction</code> to run commands within a SQL transaction. 1. You should know how to pass a transaction object as the <code>{ transaction: tx }</code> parameter to a Sequelize command (such as <code>save</code>). 1. You should know what a <em>race condition</em> is: the possibility that someone else modifies previously fetched data before you are finished using/updating it. 1. You should know how to use transactions to guard against race conditions. That is: you should know that both reading and writing operations should be put in the same transaction.</li>
</ol>
<hr />
<h1 id="recipe-box-project">Recipe Box Project</h1>
<p>In this project, you will build the Data Access Layer to power a Web application. This means that you will provide all of the SQL that it takes to get data into and from the database. You will do this in SQL files that the application will load and read.</p>
<p><strong>Note</strong>: This is not a good way to create a database-backed application. This project is structured this way so that it isolates the activity of SQL writing. Do not use this project as a template for your future projects.</p>
<h2 id="the-data-model-analysis">The data model analysis</h2>
<p>What goes into a recipe box? Why, recipes, of course! Here’s an example recipe card.</p>
<p>[Recipe card]</p>
<p>You can see that a recipe is made up of three basic parts:</p>
<ul>
<li>A title, * A list of ingredients, and * A list of instructions.</li>
</ul>
<p>You’re going to add a little more to that, too. It will also have</p>
<ul>
<li>The date/time that it was entered into the recipe box, and * The date/time it was last updated in the recipe box.</li>
</ul>
<p>These are good pieces of data to have so that you can show them “most recent” for example.</p>
<p>Ingredients themselves are complex data types and need their own structure. They “belong” to a recipe. That means they’ll need to reference that recipe. That means an ingredient is made up of:</p>
<ul>
<li>An amount (optional), * A unit of measure (optional), * The actual food stuff, and * The id of the recipe that it belongs to.</li>
</ul>
<p>That unit of measure is a good candidate for normalization, don’t you think? It’s a predefined list of options that should not change and that you don’t want people just typing whatever they want in there, not if you want to maintain data integrity. Otherwise, you’ll end up with “C”, “c”, “cup”, “CUP”, “Cup”, and all the other permutations, each of which is a distinct value but means the same thing.</p>
<p>Instructions are also complex objects, but not by looking at them. Initially, one might only see text that comprises an instruction. But, very importantly, instructions have <em>order</em>. They also <em>belong</em> to the recipe. With that in mind, an instruction is made up of:</p>
<ul>
<li>The text of the instruction, * The order that it appears in the recipe, and * The id of the recipe that it belongs to.</li>
</ul>
<p>That is enough to make a good model for the recipe box.</p>
<p>[recipe box data model]</p>
<h2 id="getting-started">Getting started</h2>
<ul>
<li>Download the starter project from https://github.com/appacademy-starters/sql-recipe-box * Run <code>npm install</code> to install the packages * Run <code>npm start</code> to start the server on port 3000</li>
</ul>
<p>You’ll do all of your work in the <strong>data-access-layer</strong> directory. In there, you will find a series of SQL files. In each, you will find instructions of what to do to make the user interface to work. They are numbered in an implied order for you to complete them. The only real requirement is that you finish the SQL for the <strong>00a-schema.sql</strong> and <strong>00b-seed.sql</strong> files first. That way, as you make your way through the rest of the SQL files, the tables and some of the data will already exist for you. You can run the command <code>npm run seed</code> to run both of those files or pipe each it into <code>psql</code> as you’ve been doing.</p>
<p>Either way that you decide to seed the database, you’ll need to stop your server. The seed won’t correctly run while the application maintains a connection to the application database. You may also need to exit all of the active <code>psql</code> instances that you have running to close out all of the active connections. When you run the seed, if it reports that it can’t do something because of active connections, look for a running instance of the server, Postbird, or <code>psql</code> with that connection.</p>
<p><strong>Warning</strong>: running the seed files will destroy all data that you have in the database.</p>
<h2 id="your-sql">Your SQL</h2>
<p>When you write the SQL, they will mostly be parameterized queries. The first couple of files will show you how it needs to be done, where you will place the parameter placeholders “$1”, “$2”, and so on. If you need to, refer to the [Parameterized query] section of the documentation for <strong>node-postgres</strong>.</p>
<p>In each of the following files in the <strong>data-access-layer</strong>, you will find one or more lines with the content <code>-- YOUR CODE HERE</code>. It is your job to write the SQL statement described in the block above that code. Each file is named with the intent of the SQL that it should contain.</p>
<h2 id="the-application">The application</h2>
<p>The application is a standard [express.js] application using the [pug] library to generate the HTML and the [node-postgres] library to connect to the database.</p>
<p>It reads your SQL files whenever it wants to make a database call. If your file throws an error, then the UI handles it by telling you what needs to be fixed so that the UI will work. The application will also output error messages for missing functionality.</p>
<p>The SQL files contain a description of what the content is and where it’s used in the application. Tying those together, you’ll know you’re done when you have all of the SQL files containing queries and there are no errors in the UI or console.</p>
<h2 id="directions">Directions</h2>
<p>Fill out the <strong>00a-schema.sql</strong> and <strong>00b-seed.sql</strong> files first. Then seed the database with command, <code>npm run seed</code>.</p>
<h3 id="home-page">Home Page</h3>
<p>Start the server by running <code>npm run dev</code>. Then go to <code>localhost:3000</code> you should see the home page with “Latest Recipes”. To show the latest recipes properly, complete the <code>01-get-ten-most-recent-recipes.sql</code> file.</p>
<p>After completing the file, make sure you correctly defined the sql query so that the first recipe listed is the most recently updated recipe.</p>
<h3 id="recipesid"><code>/recipes/:id</code></h3>
<p>If you click on one of the recipes in the list of recipes on the home page, it will direct you to that recipe’s Detail Page. Complete the following files that correspond to this page and make sure to test a file right after you fill out the file by refreshing the page: - <code>02a-get-recipe-by-id.sql</code> - <code>02b-get-ingredients-by-recipe-id.sql</code> - <code>02c-get-instructions-by-recipe-id.sql</code></p>
<p>Make sure to read the instructions well! In all the above sql queries, the <code>$1</code> parameter will be the recipe id.</p>
<h3 id="recipesnew"><code>/recipes/new</code></h3>
<p>Click on <code>ADD A RECIPE</code> button on the Navigation Bar to direct you to the New Recipe Form page. Fill out the <code>03a-insert-new-recipe.sql</code> file so you can create a new recipe.</p>
<h3 id="recipesidedit"><code>/recipes/:id/edit</code></h3>
<p>After creating a new recipe, you will be directed to the Recipe Edit page where you can add instructions and ingredients to a recipe. Complete the following files that correspond to this page and make sure to test a file right after you fill out the file: - <code>03b-get-units-of-measure.sql</code> - <code>04-insert-new-ingredient.sql</code> - <code>05-insert-new-instruction.sql</code> - <code>06-delete-recipe.sql</code></p>
<h3 id="recipestermsearchterm"><code>/recipes?term={searchTerm}</code></h3>
<p>Allow users to find recipes by a part of their name using the Search Bar in the Navigation Bar. Complete <code>07-search-recipes.sql</code> for this feature.</p>
<p>[Recipe card]: images/sql-recipe-card.jpeg [express.js]: https://www.expressjs.com [pug]: https://pugjs.org [node-postgres]: https://node-postgres.com [Parameterized query]: https://node-postgres.com/features/queries#Parameterized%20query [recipe box data model]: images/sql-recipe-box-data-model.png</p>
