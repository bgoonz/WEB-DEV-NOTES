{
  "template": {
    "taskId": "d9c62bd1-4a67-4dcc-8994-e2de9faa57f6",
    "name": "Table Management Walk-Through Part 1",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/sql/readings/reading-04-creating-tables-i-sql.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "table-management-walk-through-part-1"
    ],
    "topic": "Monday - Hello, Database!",
    "subtopic": "Lecture",
    "body": "# Table Management -  Part I\n\n**This is a walk-through**: Please type along as you read what's going on in\nthis article.\n\nIn this walk-through, you will\n\n* Learn about what a table is,\n* How to create and delete tables,\n* Who owns a table, and,\n* Learn about different data types that you can use when defining a table.\n\nYou can now create users that can connect to the relational database management\nsystem. You can now create databases and secure them so only certain users can\nconnect to them. Now, it's time to get into the part where you define the\nentities that actually hold the data: **tables**!\n\n## What is a table?\n\nA table is a \"logical\" structure that defines how data is stored and contains\nthat data that meets the definition. Most people think about tables like\nspreadsheets that have a specific number of columns and rows that contain the\ndata.\n\nIt is called a \"logical\" structure because we reason about it in terms of\ncolumns and rows; however, the RDMBS is in charge of how the data is actually\nstored on disk and, quite often, for performance reasons, it does _not_ look\nlike rows and columns. The way it is stored on disk is called the \"physical\"\nstructure because that's what is the actual physical representation of it. We do\nnot cover physical structures because they vary by RDBMS. If you become a\n**database administrator** in the future, you may have to learn such things.\n\nHere is a spreadsheet that contains some data about puppies.\n\n![Puppies spreadsheet]\n\nYou can see that the columns are\n\n* name\n* age_yrs\n* breed\n* weight_lbs\n* microchipped\n\nNow, look at the data each column contains. You can guess at what kind of data\ntype is in each of them by their values. If you were to write that out using the\ndata types that you know from JavaScript, you might come up with the following\ntable.\n\n| Column       | Data type |\n|--------------|-----------|\n| name         | string    |\n| age_yrs      | number    |\n| breed        | string    |\n| weight_lbs   | number    |\n| microchipped | Boolean   |\n\nIn table definitions, you have to be more specific, unfortunately. This is so\nthe database can know things like \"the maximum length of the string\" or \"will\nthe number have decimal points\"? This is important information so that database\ncan know how to store it most efficiently. The following table shows you the\ncorresponding ANSI SQL data types for the JavaScript types from before.\n\n| Column       | JavaScript data type | Max length | ANSI SQL data type |\n|--------------|----------------------|------------|--------------------|\n| name         | string               | 50         | VARCHAR(50)        |\n| age_yrs      | number               |            | NUMERIC(3,1)       |\n| breed        | string               | 100        | VARCHAR(100)       |\n| weight_lbs   | number               |            | INTEGER            |\n| microchipped | Boolean              |            | BOOLEAN            |\n\nYou can see that \"string\" values map to something called a \"VARCHAR\" with a\nmaximum length.\n\nYou can see that \"number\" values map to something called a \"NUMERIC\" with some\nnumbers, or an INTEGER which is just a whole number.\n\nYou can see that \"Boolean\" values map to something called a \"BOOLEAN\" which is\nnice because that's convenient.\n\n## Defining tables\n\nTo define a table, you need to know what the different pieces of related data it\nwill store. Then, you need to know what kind each of those pieces are. Once you\nhave that, you can create a table with an ANSI SQL statement.\n\n### String types\n\nThere are three kinds of commonly used string types that databases support based\non the ANSI SQL standard. This section talks about them.\n\nThe most commonly used type is known as the **CHARACTER VARYING** type. It means\nthat it can contain text of varying lengths up to a specified maximum. That\nmaximum is provided when you define the table. Instead of having to type\n_CHARACTER VARYING_ all the time, you can use its weirdly named alias\n**VARCHAR**, (pronounced \"var-car\" or \"var-char\" where each part rhymes with\n\"car\"). So, to specify that a column can hold up to 50 characters, you would\nwrite `VARCHAR(50)` in the table definition. (Remember, SQL is case insensitive\nfor its keywords. You can also write `varchar(50)` or `VarChar(50)` if you so\ndesired. Just be consistent.)\n\nAnother commonly used type is known simply as **TEXT**. This is a column that\ncan contain an \"unlimited\" number of characters. You may ask yourself, \"Why\ndon't I just always use TEXT, then?\" Performance is the reason. Columns with the\n_TEXT_ type are notoriously slower than those with other string types. Use them\njudiciously.\n\nPurposefully left out from this discussion is a type named **CHARACTER** or\n**CHAR**. It is like the **VARCHAR**, except that it is a fixed-width character\nfield. This author has _never_ seen it used in a production system except for\nOracle DB which did not, at one time, support a Boolean type. Other than that,\nit was only useful back in the 1970s - 1990s when computer disk space and speed\nwere slow and expensive.\n\n### Numeric types\n\nANSI SQL (and PostgreSQL) supports **INTEGER**, **NUMERIC**, and floating-point\nnumbers.\n\nThe _INTEGER_ should be familiar. It's just a number. In PostgreSQL, it can hold\nalmost all values that your application can handle. That's from -2,147,483,648\nto +2,147,483,647. If, for some reason, you were writing a database that would\ncontain a record for every person in the world, you would need integers bigger\nthan that. To solve that problem, ANSI SQL (and PostgreSQL) supports the\n**BIGINT** type that will hold values between -9,223,372,036,854,775,808 to\n9,223,372,036,854,775,807. If your application needs bigger integers, there are\nextensions available.\n\nThe **NUMERIC** type is a fixed-point number. When you specify it, it takes up\nto two arguments. The first number is the total number of digits that a number\ncan have in that column. The second number is the number of digits after the\ndecimal point that you want to track. The specification _NUMERIC(4,2)_ will hold\nthe number _23.22_, but not the numbers _123.22_ (too many total digits) or\n_23.222_ (which it will just ignore the extra decimal places and store _23.22_).\nThese exact numbers are important for things like storing values of money, where\nrounding errors could cause significant errors in calculations.\n\nIf you don't care about rounding errors, you can use the **DOUBLE PRECISION**.\nThere is no short alias for it. You can just put decimal numbers in there and\nthey will come out pretty much the same. Don't use this kind of data type for\ncolumns that contain values of money because they will round and someone will\nget in trouble, eventually.\n\n## Other data types\n\nPostgreSQL supports a lot of other data types, as well. It has specialized data\ntypes for money, dates and times, geometric types, network addresses, and JSON!\nOnes that you will use a lot in this course are the ones for dates and times, as\nwell as the one for JSON.\n\nHere's the link to the documentation on [PostgreSQL data types]. Go review the\ndocumentation for the types that support dates and times as you will need to\nknow the **TIMESTAMP** and **DATE** types.\n\n## Naming a table\n\nNames of tables should not create spaces or dashes. They should contain only\nlower case letters, numbers, and underscores.\n\nConventionally, many software developers name their database table names as the\nplural form of the data that it holds. More importantly, many software libraries\nknown as ORMs (which you will cover, this week) use the plural naming\nconvention. You should use the plural naming convention while here at App\nAcademy.\n\n* Good table names\n  * student_grades\n  * office_locations\n  * people\n* Bad (incorrect) table names\n  * Student Grades\n  * office-locations\n  * person\n\n**Note**: The opinion that database table names should be plural is the subject\nof heated debate among many software developers. We don't argue about it at App\nAcademy. We acknowledge that it _really doesn't matter_ how they're named. You\nshould just be consistent in the way they're named. Because our tools will use\nthe plural forms, we use the plural forms.\n\n## Writing the SQL\n\nCreating a table with SQL has this general syntax.\n\n```sql\nCREATE TABLE «table name» (\n  «column name» «data type»,\n  «column name» «data type»,\n  ...\n  «column name» «data type»\n);\n```\n\nA couple of things to note. First, it uses parentheses, not curly braces. Many\ndevelopers that use curly brace languages like JavaScript will eventually, out\nof habit, put curly braces instead of parentheses. If you were to do that, the\nRDBMS will tell you that you have a syntax error. Just grin and replace the\ncurly braces with parentheses.\n\nAnother thing to note is that the last column specification _cannot_ have a\ncomma after it. In JavaScript, we can have commas after the last entry in an\narray or in a literal object definition. Not so in SQL. Again, the RDBMS will\ntell you that there is a syntax error. Just delete that last comma.\n\nHere's the table that contains the column definitions for the \"puppies\"\nspreadsheet from before.\n\n| Column       | JavaScript data type | Max length | ANSI SQL data type |\n|--------------|----------------------|------------|--------------------|\n| name         | string               | 50         | VARCHAR(50)        |\n| age_yrs      | number               |            | NUMERIC(3,1)       |\n| breed        | string               | 100        | VARCHAR(100)       |\n| weight_lbs   | number               |            | INTEGER            |\n| microchipped | Boolean              |            | BOOLEAN            |\n\nTo write that as SQL, you would just put in the table name, column names, and\ndata types in the syntax from above. You would get the following.\n\n```sql\nCREATE TABLE puppies (\n  name VARCHAR(50),\n  age_yrs NUMERIC(3,1),\n  breed VARCHAR(100),\n  weight_lbs INTEGER,\n  microchipped BOOLEAN\n);\n```\n\nLog into your database, if you're not already. (Make sure you're in _your_\ndatabase by looking at the prompt. It should read `«your user name»=#`.) Type in\nthe SQL statement from above. If you do it correctly, PostgreSQL will return the\nmessage \"CREATE TABLE\".\n\n## Listing tables and table definitions\n\nYou can see the tables in your database by typing `\\dt` at the `psql` shell\nprompt. The `\\dt` command means \"describe tables\". If you do that now, assuming\nthat you've only created the \"puppies\" table, you should see the following with\nyour user name, of course.\n\n```\n           List of relations\n Schema |  Name   | Type  |   Owner\n--------+---------+-------+------------\n public | puppies | table | appacademy\n```\n\nThe user that runs the SQL statement that creates the table is the owner of that\ntable. Table owners, like database owners, will always be able to access the\ntable and its data. If you want a user other than the one that you're logged in\nas to own the table, you have two ways of doing that.\n\n* Log out and log in as the user that you want to own the table and run the\n  `CREATE TABLE` statement as that user.\n* As the superuser, run the `SET ROLE «user name»` command to switch the current\n  user and run the `CREATE TABLE` statement as that user.\n\nTo see the definition of a particular table table, type `\\d «table name»`. For\npuppies, type `\\d puppies`. You should see the following output.\n\n```\n                         Table \"public.puppies\"\n    Column    |          Type          | Collation | Nullable | Default\n--------------+------------------------+-----------+----------+---------\n name         | character varying(50)  |           |          |\n age_yrs      | numeric(3,1)           |           |          |\n breed        | character varying(100) |           |          |\n weight_lbs   | integer                |           |          |\n microchipped | boolean                |           |          |\n```\n\nFor now, ignore the \"Collation\", \"Nullable\", and \"Default\" columns in that\noutput. The next article will address \"Nullable\" and \"Default\".\n\nYou can see that the data types that you provided have been translated into\ntheir ANSI SQL full name equivalents.\n\nNow, connect to the \"postgres\" database using the `\\c postgres` command. It\nshould give you a message that you're now connected to the \"postgres\" database\nas your user. The prompt should change from one that has your name to\n`postgres=#`. Now, type `\\dt` to list the tables in the \"postgres\" database. If\nyou haven't created any tables there, it will read \"Did not find any relations.\"\nIf you type `\\d puppies`, it will report that it can't find a relation named\n\"puppies\".\n\nThis is because you're in a different database than the one in which you created\nthe \"puppies\" table. You just don't see the \"puppies\" table, here, because it\ndoesn't exit. That table is in another database, your user database. That's how\ndatabases work: they provide an area where you can create tables in which you'll\nstore data. Different databases have different tables. You can't easily get at\ntables in another database from the one that you're currently in. And, really,\nyou don't want to. Databases provide the storage and security boundaries for\ndata.\n\nChange back to your user database by executing the command `\\c «your user\nname»`.\n\n## Deleting a table\n\nIn the same way that you can delete users and databases by using the `DROP`\ncommand, you can do the same for tables. To get rid of the \"puppies\" table,\nexecute the following SQL command.\n\n```sql\nDROP TABLE puppies;\n```\n\nIt should tell you that it dropped the table. You can confirm that it is no\nlonger there by executing the `\\dt` command.\n\n## What you've done\n\nIn this section, you learned the basics about creating database entities called\n\"tables\" and their ownership. You learned that tables are where you store data.\nYou discovered that the data that you store is defined by the columns and their\ndata types. You can now write SQL to create and drop tables.\n\nNext up, you will learn about special kinds of columns, column constraints, and\nbuilding relations between tables.\n\n[Puppies spreadsheet]: https://appacademy-open-assets.s3-us-west-1.amazonaws.com/Module-SQL/assets/tables-puppies-spreadsheet.png\n[PostgreSQL data types]: https://www.postgresql.org/docs/current/datatype.html\n"
  },
  "success": true
}