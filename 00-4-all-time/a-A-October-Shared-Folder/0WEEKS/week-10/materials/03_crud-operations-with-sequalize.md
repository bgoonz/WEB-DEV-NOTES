# CRUD Operations Using Sequelize
________________________________________________________________________________
<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [Creating A New Record](#creating-a-new-record)
- [Reading A Record By Primary Key](#reading-a-record-by-primary-key)
- [Updating A Record](#updating-a-record)
- [Destroying A Record](#destroying-a-record)
- [Class Methods For CRUD](#class-methods-for-crud)
- [Conclusion](#conclusion)

<!-- /code_chunk_output -->
________________________________________________________________________________

There are four general ways to interact with a database. To illustrate
these, recall our `Cats` table. We can:

1. Save a new cat to the database by _creating_ a new row in the
   `Cats` table,
2. We can _read_ previously stored cat data by fetching a row (or
   multiple rows) out of the `Cats` table,
3. We can _update_ some of the column values for a pre-existing cat by
   modifying a row in the `Cats` table,
4. We can delete (_destroy_) the data for a cat by removing a row in
   the `Cats` table.

These four actions are sometimes abbreviated as _CRUD_. After this
reading, you will be able to:

* Use Sequelize to create new records in a table,
* Use Sequelize to read/fetch existing records by primary key,
* Use Sequelize to update existing records with new attribute values,
* Use Sequelize to delete records from a table.

## Creating A New Record

To save a new cat's data as a row in the `Cats` table, we do a two step
process:

1. We call the static `build` method on the `Cat` class with the desired values.
2. We call the `save` method on the `cat` instance.

Let's see an example:

```javascript
const { sequelize, Cat } = require("./models");

async function main() {
  // Constructs an instance of the JavaScript `Cat` class. **Does not
  // save anything to the database yet**. Attributes are passed in as a
  // POJO.
  const cat = Cat.build({
    firstName: "Markov",
    specialSkill: "sleeping",
    age: 5,
  });

  // This actually creates a new `Cats` record in the database. We must
  // wait for this asynchronous operation to succeed.
  await cat.save();

  console.log(cat.toJSON());

  await sequelize.close();
}

main();
```

Running the code:

```
Executing (default): INSERT INTO "Cats" ("id","firstName","specialSkill","age","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3,$4,$5) RETURNING *;
{
  id: 1,
  firstName: 'Markov',
  specialSkill: 'sleeping',
  age: 5,
  updatedAt: 2020-02-11T19:04:23.116Z,
  createdAt: 2020-02-11T19:04:23.116Z
}
```

A new row has been inserted into the `Cats` table. We see that `id`,
`updatedAt`, and `createdAt` were each autogenerated for us.

## Reading A Record By Primary Key

Let's read an existing record from the database:

```javascript
const { sequelize, Cat } = require("./models");

async function main() {
  // Fetch the cat with id #1.
  const cat = await Cat.findByPk(1);
  console.log(cat.toJSON());

  await sequelize.close();
}

main();
```

Running this code prints:

```
Executing (default): SELECT "id", "firstName", "specialSkill", "age", "createdAt", "updatedAt" FROM "Cats" AS "Cat" WHERE "Cat"."id" = 1;
{
  id: 1,
  firstName: 'Markov',
  specialSkill: 'sleeping',
  age: 5,
  createdAt: 2020-02-11T19:04:23.116Z,
  updatedAt: 2020-02-11T19:04:23.116Z
}
```

Fetching a record by primary key is the most common form of read
operation from a database. In another reading we will learn other ways
to fetch data. For instance: we will learn how to fetch all cats named
"Markov" (there may be many).

## Updating A Record

Let's tweak our reading code to change (_update_) an attribute of Markov:

```javascript
const { sequelize, Cat }  = require("./models");

async function main() {
  const cat = await Cat.findByPk(1);

  console.log("Old Markov: ");
  console.log(cat.toJSON());

  // The Cat object is modified, but the corresponding record in the
  // database is *not* yet changed at all.
  cat.specialSkill = "super deep sleeping";
  // Only by calling `save` will the data be saved.
  await cat.save();

  console.log("New Markov: ");
  console.log(cat.toJSON());

  await sequelize.close();
}

main();
```

Running this code prints:

```
Executing (default): SELECT "id", "firstName", "specialSkill", "age", "createdAt", "updatedAt" FROM "Cats" AS "Cat" WHERE "Cat"."id" = 1;
Old Markov:
{
  id: 1,
  firstName: 'Markov',
  specialSkill: 'sleeping',
  age: 5,
  createdAt: 2020-02-11T19:04:23.116Z,
  updatedAt: 2020-02-11T19:04:23.116Z
}
Executing (default): UPDATE "Cats" SET "specialSkill"=$1,"updatedAt"=$2 WHERE "id" = $3
New Markov:
{
  id: 1,
  firstName: 'Markov',
  specialSkill: 'super deep sleeping',
  age: 5,
  createdAt: 2020-02-11T19:04:23.116Z,
  updatedAt: 2020-02-11T19:15:08.668Z
}
```

**Important note**: changing an attribute of a `Cat` object does not
immediately change any data in the `Cats` table. To change data in the
`Cats` table, you must also call `save`. If you forget to call `save`,
no data will be changed. `save` is asynchronous, so you must also
`await` for it to complete.

If you look carefully, you can see that the `updatedAt` attribute was
changed for us when we updated Markov!

## Destroying A Record

We can also destroy records and remove them from the database:

```javascript
const process = require("process");

const { sequelize , Cat } = require("./models");

async function main() {
  const cat = await Cat.findByPk(1);
  // Remove the Markov record.
  await cat.destroy();

  await sequelize.close();
}

main();
```

This code prints:

```
Executing (default): SELECT "id", "firstName", "specialSkill", "age", "createdAt", "updatedAt" FROM "Cats" AS "Cat" WHERE "Cat"."id" = 1;
Executing (default): DELETE FROM "Cats" WHERE "id" = 1
```

## Class Methods For CRUD

When creating a record, you can avoid the two step process of (1)
creating a `Cat` instance and (2) calling the `save` instance method.
You can do a one step process of calling the `create` **class method**:

```javascript
const { sequelize, Cat } = require("./models");

async function main() {
  const cat = await Cat.create({
    firstName: "Curie",
    specialSkill: "jumping",
    age: 4,
  });

  console.log(cat.toJSON());

  await sequelize.close();
}

main();
```

The `create` class method does both steps in one. It is just a
convenience. Similar to before, this code prints:

```
Executing (default): INSERT INTO "Cats" ("id","firstName","specialSkill","age","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3,$4,$5) RETURNING *;
{
  id: 3,
  firstName: 'Curie',
  specialSkill: 'jumping',
  age: 4,
  updatedAt: 2020-02-11T19:36:03.858Z,
  createdAt: 2020-02-11T19:36:03.858Z
}
```

When destroying, we also did a two step process: (1) fetch the record,
(2) call the `destroy` instance method. Instead, we could just call the
`destroy` **class method** directly:

```javascript
const { sequelize, Cat } = require("./models");

async function main() {
  // Destroy the Cat record with id #3.
  await Cat.destroy({ where: { id: 3 } });

  await sequelize.close();
}

main();
```

This prints:

```
Executing (default): DELETE FROM "Cats" WHERE "id" = 3
```

An advantage to the class method form of destroying is that we avoid an
unnecessary fetch of `Cat.findByPk(3)`. Database queries can
sometimes be slow, though typically a few extra queries won't make a big
difference. Choosing between the instance and class methods of
destroying usually comes down to which you consider easier to
read/understand.

## Conclusion

As ever, the best resource for learning about Sequelize model methods is
the [documentation][sequelize-model-documentation]. The documentation
explains the `create`, `destroy`, `findByPk`, and `save` methods
in depth.

[sequelize-model-documentation]: https://sequelize.org/master/class/lib/model.js~Model.html

Having completed this reading, you now know how to:

* Use Sequelize to create new records in a table (using both instance
  and class methods),
* Use Sequelize to read/fetch existing records by primary key,
* Use Sequelize to update existing records with new attribute values,
* Use Sequelize to delete records from a table (using both instance and
  class methods).
