{
  "template": {
    "taskId": "a1f0578d-6b6a-483f-8c2e-83460c23d2a6",
    "name": "Accessing Data From Node.js",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/sql/readings/reading-16-prepared-statements.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "accessing-data-from-node-js"
    ],
    "topic": "Homework for Wednesday",
    "subtopic": "Homework",
    "body": "# Node-Postgres AndPrepared Statements\n\nThe library [node-postgres] is, not too surprisingly, the library that Node.js\napplications use to connect to a database managed by a PostgreSQL RDBMS. The\napplications that you deal with will use this library to make connections to the\ndatabase and get rows returned from your SQL `SELECT` statements.\n\n## Connecting\n\nThe **node-postgres** library provides two ways to connect to it. You can use a\nsingle `Client` object, or you can use a `Pool` of `Client` objects. Normally,\nyou want to use a `Pool` because creating and opening single connections to any\ndatabase server is a \"costly\" operation in terms of CPU and network resources.\nA `Pool` creates a group of those `Client` connections and lets your code use\nthem whenever it needs to.\n\nTo use a `Pool`, you specify any specific portions of the following connection\nparameters that you need. The default values for each parameter is listed with\neach parameter.\n\n| Connection parameter | What it indicates                           | Default value                           |\n|----------------------|---------------------------------------------|-----------------------------------------|\n| user                 | The name of the user you want to connect as | The user name that runs the application |\n| password             | The password to use                         | The password set in your configuration  |\n| database             | The name of the database to connect to      | The user's database                     |\n| port                 | The port over which to connect              | 5432                                    |\n| host                 | The name of the server to connect to        | localhost                               |\n\nNormally, you will only override the user and password fields, and sometimes the\ndatabase if it doesn't match the user's name. You do that by instantiating a\nnew `Pool` object and passing in an object with those key/value pairs.\n\n```js\nconst { Pool } = require('pg');\n\nconst pool = new Pool({\n  user: 'application_user',\n  password: 'iy7qTEcZ',\n});\n```\n\nOnce you have an instance of the `Pool` class, you can use the `query` method on\nit to run queries. (The `query` method returns a Promise, so it's nice to just\nuse `await` for it to finish.)\n\n```js\nconst results = await pool.query(`\n  SELECT id, name, age_yrs\n  FROM puppies;\n`);\n\nconsole.log(results);\n```\n\nWhen this runs, you will get an object that contains a property named \"rows\".\nThe value of \"rows\" will be an array of the rows that match the statement.\nHere's an example output from the code above.\n\n```\n{\n  rows:\n    [ { id: 1, name: 'Cooper', age_yrs: '1.0' },\n      { id: 2, name: 'Indie', age_yrs: '0.5' },\n      { id: 3, name: 'Kota', age_yrs: '0.7' },\n      { id: 4, name: 'Zoe', age_yrs: '0.8' },\n      { id: 5, name: 'Charley', age_yrs: '1.5' },\n      { id: 6, name: 'Ladybird', age_yrs: '0.6' },\n      { id: 7, name: 'Callie', age_yrs: '0.9' },\n      { id: 8, name: 'Jaxson', age_yrs: '0.4' },\n      { id: 9, name: 'Leinni', age_yrs: '1.0' },\n      { id: 10, name: 'Max', age_yrs: '1.6' } ],\n}\n```\n\nYou can see that the \"rows\" property contains an array of objects. Each object\nrepresents a row in the \"puppies\" table that matches the query. Each object has\na property named after the column selected in the `SELECT` statement. The query\nread `SELECT id, name, age_yrs` and each object has an \"id\", \"name\", and an\n\"age_yrs\" property.\n\nYou can then use that array to loop over and do things with it. For example,\nyou could print them to the console like this:\n\n```js\nfor (let row of results.rows) {\n  console.log(`${row.id}: ${row.name} is ${row.age_yrs} old</li>`);\n}\n```\n\nWhich would show\n\n```\n1. Cooper is 1.0 years old\n2. Indie is 0.5 years old\n3. Kots is 0.7 years old\n...\n```\n\n## Prepared Statement\n\nPrepared statements are SQL statements that have parameters in them that you can\nuse to substitute values. The parameters are normally part of the `WHERE` clause\nin all statements. You will also use then in the `SET` portion of `UPDATE`\nstatements and the `VALUES` portion of `INSERT` statements.\n\nFor example, say your application collected the information to create a new row\nin the puppy table by asking for the puppy's name, age, breed, weight, and if\nit was microchipped. You'd have those values stored in variables somewhere.\nYou'd want to create an `INSERT` statement that inserts the data from those\nvariables into a SQL statement that the RDBMS could then execute to insert a\nnew row.\n\nThink about what a generic `INSERT` statement would look like. It would have to\nhave the\n\n```sql\nINSERT INTO puppies (name, age_yrs, breed, weight_lbs, microchipped)\n```\n\nportion of the statement. The part that would change with each time you inserted\nwould be the specific values that would go into the `VALUES` section of the\n`INSERT` statement. With prepared statements, you use _positional parameters_\nto act as placeholders for the actual values that you will provide the query.\n\nFor example, the generic `INSERT` statement from above would look like this.\n\n```sql\nINSERT INTO puppies (name, age_yrs, breed, weight_lbs, microchipped)\nVALUES ($1, $2, $3, $4, $5);\n```\n\nEach of the \"$\" placeholders is a positional argument for the parameters that\nyou pass in. That means, the value that pass in for the first parameter will be\nput where the \"$1\" placeholder is, which is the value for the \"name\" of the\npuppy. The \"$2\" corresponds to the \"age_yrs\" column, so it should contain the\nage of the puppy. This continues for the third, fourth, and fifth parameters,\nas well.\n\nAssume that in your code, you have the variables `name`, `age`, `breedName`,\n`weight`, and `isMicrochipped` containing the values that the user provided for\nthe new puppy. Then, your use of the `query` method will now include another\nargument, the values that you want to pass in inside an array.\n\n```js\nawait pool.query(`\n  INSERT INTO puppies (name, age_yrs, breed, weight_lbs, microchipped)\n  VALUES ($1, $2, $3, $4, $5);\n`, [name, age, breedName, weight, isMicrochipped]);\n```\n\nYou can see that the variable `name` is in the first position of the array, so\nit will be substituted into the placeholder \"$1\". The `age` variable is in the\nsecond position of the array, so it will be substituted into the \"$2\"\nplaceholder.\n\nThe full documentation for how to use queries with **node-postgres** can be\nfound on the [Queries] documentation page on their Web site.\n\n## Try it out for yourself\n\nMake sure you have a database with a table that has data in it. If you don't,\ncreate a new database and run the following SQL.\n\n```sql\nCREATE TABLE puppies (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(50) NOT NULL,\n  age_yrs NUMERIC(3,1) NOT NULL,\n  breed VARCHAR(100) NOT NULL,\n  weight_lbs INTEGER NOT NULL,\n  microchipped BOOLEAN NOT NULL DEFAULT FALSE\n);\n\ninsert into puppies(name, age_yrs, breed, weight_lbs, microchipped)\nvalues\n('Cooper', 1, 'Miniature Schnauzer', 18, 'yes'),\n('Indie', 0.5, 'Yorkshire Terrier', 13, 'yes'),\n('Kota', 0.7, 'Australian Shepherd', 26, 'no'),\n('Zoe', 0.8, 'Korean Jindo', 32, 'yes'),\n('Charley', 1.5, 'Basset Hound', 25, 'no'),\n('Ladybird', 0.6, 'Labradoodle', 20, 'yes'),\n('Callie', 0.9, 'Corgi', 16, 'no'),\n('Jaxson', 0.4, 'Beagle', 19, 'yes'),\n('Leinni', 1, 'Miniature Schnauzer', 25, 'yes' ),\n('Max', 1.6, 'German Shepherd', 65, 'no');\n```\n\nNow that you have ten rows in the \"puppies\" table of a database, you can create\na simple Node.js project to access it.\n\nCreate a new directory somewhere that's not part of an existing project. Run\n`npm init -y` to initialize the **package.json** file. Then, run `npm install\npg` to install the library from this section. (Why is the name of the library\n\"node-postgres\" but you install \"pg\"? Dunno.) Finally, open Visual Studio Code\nfor the current directory with `code .`.\n\nCreate a new file named **sql-test.js**.\n\nThe first thing you need to do is import the `Pool` class from the\n**node-postgres** library. The name of the library in the **node_modules**\ndirectory is \"pg\". That line of code looks like this and can be found all over the\n[node-postgres] documentation.\n\n```js\nconst { Pool } = require('pg');\n```\n\nNow, write some SQL that will select all of the records from the \"puppies\"\ntable. (This is assuming you want to select puppies. If you're using a different\ntable with different data, write the appropriate SQL here.)\n\n```js\nconst { Pool } = require('pg');\n\nconst allPuppies = `\n  SELECT id, name, age_yrs, breed, weight_lbs, microchipped\n  FROM puppies;\n`;\n```\n\nYou will now use that with a new `Pool` object. You will need to know the name\nof the database that the \"puppies\" table is in (or whatever database you want\nto connect to).\n\n```js\nconst { Pool } = require('pg');\n\nconst allPuppies = `\n  SELECT id, name, age_yrs, breed, weight_lbs, microchipped\n  FROM puppies;\n`;\n\nconst pool = new Pool({\n  database: '«database name»'\n});\n```\n\nOf course, replace \"«database name»\" with the name of your database. Otherwise,\nwhen you run it, you will see this error message.\n\n```\nUnhandledPromiseRejectionWarning: error: database \"«database name»\" does not exist\n```\n\nThis will, by default, connect to \"localhost\" on port \"5432\" with your user\ncredentials because you did not specify any other parameters.\n\nOnce you have the pool, you can execute the query that you have in `allPuppies`.\nRemember that the `query` method returns a Promise. This code wraps the call to\n`query` in an `async function` so that it can use the `await` keyword for\nsimplicity's sake. Then, it prints out the rows that it fetched to the console.\nFinally, it calls `end` on the connection pool object to tell **node-postgres**\nto close all the connections and quit. Otherwise, your application will just\nhang and you'll have to close it with Control+C.\n\n```js\nconst { Pool } = require('pg');\n\nconst allPuppiesSql = `\n  SELECT id, name, age_yrs, breed, weight_lbs, microchipped\n  FROM puppies;\n`;\n\nconst pool = new Pool({\n  database: '«database name»'\n});\n\nasync function selectAllPuppies() {\n  const results = await pool.query(allPuppiesSql);\n  console.log(results.rows);\n  pool.end();\n}\n\nselectAllPuppies();\n```\n\nWhen you run this with `node sql-test.js`, you should see some output like this\nalthough likely in a nicer format.\n\n```\n[ { id: 1, name: 'Cooper', age_yrs: '1.0', breed: 'Miniature Schnauzer', weight_lbs: 18, microchipped: true },\n  { id: 2, name: 'Indie', age_yrs: '0.5', breed: 'Yorkshire Terrier', weight_lbs: 13, microchipped: true },\n  { id: 3, name: 'Kota', age_yrs: '0.7', breed: 'Australian Shepherd', weight_lbs: 26, microchipped: false },\n  { id: 4, name: 'Zoe', age_yrs: '0.8', breed: 'Korean Jindo', weight_lbs: 32, microchipped: true },\n  { id: 5, name: 'Charley', age_yrs: '1.5', breed: 'Basset Hound', weight_lbs: 25, microchipped: false },\n  { id: 6, name: 'Ladybird', age_yrs: '0.6', breed: 'Labradoodle', weight_lbs: 20, microchipped: true },\n  { id: 7, name: 'Callie', age_yrs: '0.9', breed: 'Corgi', weight_lbs: 16, microchipped: false },\n  { id: 8, name: 'Jaxson', age_yrs: '0.4', breed: 'Beagle', weight_lbs: 19, microchipped: true },\n  { id: 9, name: 'Leinni', age_yrs: '1.0', breed: 'Miniature Schnauzer', weight_lbs: 25, microchipped: true },\n  { id: 10, name: 'Max', age_yrs: '1.6', breed: 'German Shepherd', weight_lbs: 65, microchipped: false } ]\n```\n\nNow, try one of those parameterized queries. Comment out the `selectAllPuppies`\nfunction and invocation.\n\n```js\n// async function selectAllPuppies() {\n//   const results = await pool.query(allPuppiesSql);\n//   console.log(results.rows);\n//   pool.end();\n// }\n\n// selectAllPuppies();\n```\n\nAdd the following content to the bottom of the file.\n\n```js\n// Define the parameterized query where it will select a puppy\n// based on an id\nconst singlePuppySql = `\n  SELECT id, name, age_yrs, breed, weight_lbs, microchipped\n  FROM puppies\n  WHERE ID = $1;\n`;\n\n// Run the parameterized SQL by passing in an array that contains\n// the puppyId to the query method. Then, print the results and\n// end the pool.\nasync function selectOnePuppy(puppyId) {\n  const results = await pool.query(singlePuppySql, [puppyId]);\n  console.log(results.rows);\n  pool.end();\n}\n\n// Get the id from the command line and store it\n// in the variable \"id\". Pass that value to the\n// selectOnePuppy function.\nconst id = Number.parseInt(process.argv[2]);\nselectOnePuppy(id);\n```\n\nNow, when you run the program, include a number after the command. For example,\nif you run `node sql-test.js 1`, it will print out\n\n```\n[ { id: 1,\n    name: 'Cooper',\n    age_yrs: '1.0',\n    breed: 'Miniature Schnauzer',\n    weight_lbs: 18,\n    microchipped: true } ]\n```\n\nIf you run `node sql-test.js 4`, it will print out\n\n```\n[ { id: 4,\n    name: 'Zoe',\n    age_yrs: '0.8',\n    breed: 'Korean Jindo',\n    weight_lbs: 32,\n    microchipped: true } ]\n```\n\nThat's because the number that you type on the command line is being substituted\nin for the \"$1\" in the parameterized query. That means, when you pass in \"4\",\nIt's like the RDMBS takes the parameterized query\n\n```sql\nSELECT id, name, age_yrs, breed, weight_lbs, microchipped\nFROM puppies\nWHERE ID = $1;\n```\n\nand your value \"4\"\n\nand mushes them together to make\n\n```sql\nSELECT id, name, age_yrs, breed, weight_lbs, microchipped\nFROM puppies\nWHERE ID = 4; -- Value substituted here by PostgreSQL.\n```\n\nThat happens because when you run the query, you call the `query` method like\nthis.\n\n```js\nawait pool.query(singlePuppySql, [puppyId]);\n```\n\nwhich passes along the sql stored in `singlePuppySql` and the value stored in\n`puppyId` (as the first parameter) to PostgreSQL.\n\nWhat do you think will happen if you change `singlePuppySql` to have _two_\nparameters instead of one, but only pass in one parameter through the `query`\nmethod?\n\n```js\nconst singlePuppySql = `\n  SELECT id, name, age_yrs, breed, weight_lbs, microchipped\n  FROM puppies\n  WHERE ID = $1\n  AND age_yrs > $2;\n`;\n```\n\nPostgreSQL is smart enough to see that you've only provided one parameter value\nbut it needs _two_ positional parameters. It gives you the error message\n\n```\nerror: bind message supplies 1 parameters, but prepared statement \"\" requires 2\n```\n\nIn this error message, the term \"bind message\" is the kind of message that the\n`query` method sends to PostgreSQL when you provide parameters to it.\n\nChange the query back to how it was. Now, add an extra parameter to the\ninvocation of the `query` method. What do you think will\n\n```js\nawait pool.query(singlePuppySql, [puppyId, 'extra parameter']);\n```\n\nAgain, PostgreSQL gives you an error message about a mismatch in the number of\nplaceholders in the SQL and the number of values you passed to it.\n\n```\nerror: bind message supplies 2 parameters, but prepared statement \"\" requires 1\n```\n\n## What you've learned\n\nHere, you've seen how to connect to a PostgreSQL database using the\n**node-postgres** library named \"pg\". You saw how to run simple SQL statements\nagainst it and handle the results. You also saw how to create parameterized\nqueries so that you can pass in values to be substituted.\n\nIf you are using the **node-postgres** library and running your own handcrafted\nSQL, you will most often use parameterized queries. It's good to get familiar\nwith them.\n\n[node-postgres]: https://www.node-postgres.com\n[Queries]: https://node-postgres.com/features/queries\n"
  },
  "success": true
}