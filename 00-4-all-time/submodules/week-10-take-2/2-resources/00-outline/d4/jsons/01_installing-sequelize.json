{
  "template": {
    "taskId": "309be7ac-f48c-4ffd-a0ca-97628618d5ab",
    "name": "Installing Sequelize",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/orm/readings/reading-01-installing-and-using-sequelize-orm-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "installing-sequelize"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Installing And Using Sequelize\n\nNow that you have gained experience with SQL, it is time to learn how to\naccess data stored in a SQL database using a JavaScript program. You\nwill use a JavaScript library called Sequelize to do this. Sequelize is\nan example of an _Object Relational Mapping_ (commonly abbreviated\n_ORM_). An ORM allows a JavaScript programmer to fetch and store data in\na SQL database using JavaScript functions instead of writing SQL code.\n\nWhen you finish this reading you will be able to:\n\n* Describe what an Object Relational Mapping is and what it is used for.\n* Install and configure the packages needed to use Sequelize.\n* Use Sequelize to generate JavaScript code that fetches and stores data\n  in a SQL database.\n* Use those auto-generated methods to fetch and store data in a SQL\n  database.\n\n## What Is An ORM?\n\nAn _Object Relational Mapping_ is a library that allows you to access\ndata stored in a SQL database through object-oriented, non-SQL code\n(such as JavaScript). You will write _object-oriented_ code that\naccesses data stored in a _relational_ SQL database like Postgres. The\nORM is the _mapping_ that will \"translate\" your object-oriented code\ninto SQL code that the database can run. The ORM will automatically\ngenerate SQL code for common tasks like fetching and storing data.\n\nYou will learn how to use the [Sequelize ORM][sequelize-documentation].\nSequelize is the most widely used JavaScript ORM library.\n\n[sequelize-documentation]: https://sequelize.org/v5/\n\n## How To Install Sequelize\n\nAfter creating a new node project with `npm init` we are ready to install the\nSequelize library.\n\n```sh\nnpm install sequelize@^5.0.0\nnpm install sequelize-cli@^5.0.0\nnpm install pg@^8.0.0\n```\n\nWe have installed not only the Sequelize library, but also a command\nline tool called `sequelize-cli` that will help us auto-generate and\nmanage JavaScript files which will hold our Sequelize ORM code.\n\nLast, we have also installed the pg library. This library allows\nSequelize to access a Postgres database. If you were using a different\ndatabase software (such as MySQL), you would need to install a different\nlibrary.\n\n## How To Initialize Sequelize\n\nWe can run the command `npx sequelize init` to automatically setup the following directory structure for our project:\n\n```\n.\n├── config\n│   └── config.json\n├── migrations\n├── models\n│   └── index.js\n├── node_modules\n├── package-lock.json\n├── package.json\n└── seeders\n```\n\n>Aside: the `npx` tool allows you to easily run scripts provided by\n>packages like `sequelize-cli`. If you don't already have `npx`, you can\n>install it with `npm install npx --global`. Without `npx` you would have\n>to run the bash command: `./node_modules/.bin/sequelize init`. This\n>directly runs the `sequelize` script provided by the installed\n>`sequelize-cli` package.\n\nHaving run `npx sequelize init`, we must write our database login\ninformation into `config/config.json`.\n\nBy default this file contains different sections we call \"environments\". In a\ntypical company you will have different database servers and configuration\ndepending on where you app is running. Development is usually where you do\nyour development work. In our case this is our local computer. But test might be\nand environment where you run tests, and production is the environment where\nreal users are interacting with your application.\n\nSince we are doing development, we can just modify the \"development\" section to look\nlike this:\n\n```json\n{\n  \"development\": {\n    \"username\": \"catsdbuser\",\n    \"password\": \"catsdbpassword\",\n    \"database\": \"catsdb\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"postgres\"\n  }\n}...\n```\n\nHere we are supposing that we have already created a `catsdb` database\nowned by the user `catsdbuser`, with password `catsdbpassword`. By\nsetting `host` to `127.0.0.1`, we are saying that the database will run\non the same machine as my JavaScript application. Last, we specify that\nwe are using a `postgres` database.\n\n## Verifying That Sequelize Can Connect To The Database\n\nAt the top level of our project, we should create an `index.js` file.\nFrom this file we will verify that Sequelize can connect to the SQL\ndatabase. To do this, we use the `authenticate` method of the sequelize object.\n\n```javascript\n// ./index.js\n\nconst { sequelize } = require(\"./models\");\n\nasync function main() {\n  try {\n    await sequelize.authenticate();\n  } catch (e) {\n    console.log(\"Database connection failure.\");\n    console.log(e);\n    return;\n  }\n\n  console.log(\"Database connection success!\");\n  console.log(\"Sequelize is ready to use!\");\n\n  // Close database connection when done with it.\n  await sequelize.close();\n}\n\nmain();\n\n// Prints:\n//\n// Executing (default): SELECT 1+1 AS result\n// Database connection success!\n// Sequelize is ready to use!\n```\n\nYou may observe that the `authenticate` method returns a JavaScript\n`Promise` object. We use `await` to wait for the database connection to\nbe established. If `authenticate` fails to connect, the `Promise` will\nbe rejected. Since we use `await`, an exception will be thrown.\n\nMany Sequelize methods return `Promise`s. Using `async` and `await` lets\nus use Sequelize methods as if they were synchronous. This helps reduce\ncode complexity significantly.\n\nNote that I call `sequelize.close()`. This closes the connection to\nthe database. A Node.js JavaScript program will not terminate until all\nopen files and database connections are closed. Thus, to make sure the\nNode.js program doesn't \"hang\" at the end, we close the database\nconnection. Otherwise we will be forced to kill the Node.js program with\n`CTRL-C`, which is somewhat annoying.\n\n## Our Preexisting Database Schema\n\nWe are assuming that we are working with a preexisting SQL database. Our\n`catsdb` has a single table: `Cats`. Using the `psql` command-line\nprogram, we can describe the pre-existing `Cats` table below.\n\n```\ncatsdb=> \\d \"Cats\"\n                                         Table \"public.Cats\"\n    Column    |           Type           | Collation | Nullable |              Default\n--------------+--------------------------+-----------+----------+------------------------------------\n id           | integer                  |           | not null | nextval('\"Cats_id_seq\"'::regclass)\n firstName    | character varying(255)   |           |          |\n specialSkill | character varying(255)   |           |          |\n age          | integer                  |           |          |\n createdAt    | timestamp with time zone |           | not null |\n updatedAt    | timestamp with time zone |           | not null |\nIndexes:\n    \"Cats_pkey\" PRIMARY KEY, btree (id)\n```\n\nBesides a primary key `id`, each `Cats` record has a `firstName`, a\n`specialSkill`, and an `age`. Each record also keeps track of two\ntimestamps: the time when the cat was created (`createdAt`), and the\nmost recent time when a column of the cat has been updated\n(`updatedAt`).\n\n## Using Sequelize To Generate The Model File\n\nWe will configure Sequelize to access the `Cats` table via a JavaScript\nclass called `Cat`. To do this, we first use our trusty Sequelize CLI:\n\n```bash\n# Oops, forgot age:integer! (Don't worry we'll fix it later)\nnpx sequelize model:generate --name Cat --attributes \"firstName:string,specialSkill:string\"\n```\n\nThis command generates two files: a _model_ file (`./models/cat.js`)\nand a _migration_ file (`./migrations/20200203211508-Cat.js`). We will\nignore the migration file for now, and focus on the model file.\n\nWhen using Sequelize's `model:generate` command, we specify two things.\nFirst: we specify the _singular_ form of the `Cats` table name (`Cat`).\nSecond: we list the columns of the `Cats` table after the `--attributes`\nflag: `firstName` and `specialSkill`. We tell Sequelize that these are\nboth `string` columns (Sequelize calls SQL `character varying(255)`\ncolumns `string`s).\n\nWe do not need to list `id`, `createdAt`, or `updatedAt`. Sequelize will\nalways presume those exist. Notice that we have **forgotten** to list\n`age:integer` -- we will fix that soon!\n\n## Examining (And Modifying) A Sequelize Model File\n\nLet us examine the generated `./models/cat.js` file:\n\n```javascript\n// ./models/cat.js\n\n'use strict';\nmodule.exports = (sequelize, DataTypes) => {\n  const Cat = sequelize.define('Cat', {\n    firstName: DataTypes.STRING,\n    specialSkill: DataTypes.STRING\n  }, {});\n  Cat.associate = function(models) {\n    // associations can be defined here\n  };\n  return Cat;\n};\n```\n\nThis file exports a function that defines a `Cat` class. When you use\n`Sequelize` to query the `Cats` table, each row retrieved will be\ntransformed by Sequelize into an instance of the `Cat` class. A\nJavaScript class like `Cat` that corresponds to a SQL table is called a\n_model_ class.\n\nThe `./models/cat.js` will not be loaded by us directly. Sequelize will\nload this file and call the exported function to define the `Cat` class.\nThe exported function uses Sequelize's `define` method to auto-generate\na new class (called `Cat`).\n\n> Note: You may notice we aren't using the JavaScript's `class` keyword\n> to define the Cat class. With Sequelize, it is going to do all that for us\n> with the `define` method. This is because Sequelize was around way before\n> the `class` keyword was added to JavaScript. It is possible to use the class\n> keyword with Sequelize, but it's [undocumented].\n\nThe first argument of `define` is the name of the class to define:\n`Cat`. Notice how the second argument is an `Object` of `Cats` table\ncolumns:\n\n```javascript\n{\n    firstName: DataTypes.STRING,\n    specialSkill: DataTypes.STRING\n}\n```\n\nThis object tells Sequelize about each of the columns of `Cats`. It maps\neach column name (`firstName`, `specialSkill`) to the type of data\nstored in the corresponding column of the `Cats` table. It is\nunnecessary to list `id`, `createdAt`, `updatedAt`, since Sequelize will\nalready assume those exist.\n\nWe can correct our earlier mistake of forgetting `age`. We update the\ndefinition as so:\n\n```javascript\nconst Cat = sequelize.define('Cat', {\n  firstName: DataTypes.STRING,\n  specialSkill: DataTypes.STRING,\n  age: DataTypes.INTEGER,\n}, {});\n```\n\nA complete list of Sequelize datatypes can be found in the\n[documentation][sequelize-datatypes].\n\n[sequelize-datatypes]: https://sequelize.org/v5/manual/data-types.html\n\n## Using The `Cat` Model To Fetch And Update SQL Data\n\nWe are now ready to use our `Cat` model class. When Sequelize defines\nthe `Cat` class, it will generate instance and class methods needed to\ninteract with the `Cats` SQL table.\n\nAs we mentioned before we don't require our `cats.js` file directly.\nInstead we require `./models` which loads the file `./models/index.js`.\n\nInside this file it reads through all our models and attaches them to an object\nthat it exports. So we can use destructuring to get a reference to our model\nclass `Cat` like so:\n\n```javascript\nconst { sequelize, Cat } = require(\"./models\");\n```\n\nNow let's update _our_ `index.js` file to fetch a `Cat` from the `Cats`\ntable:\n\n```javascript\nconst { sequelize , Cat } = require(\"./models\");\n\nasync function main() {\n  try {\n    await sequelize.authenticate();\n  } catch (e) {\n    console.log(\"Database connection failure.\");\n    console.log(e);\n    return;\n  }\n\n  console.log(\"Database connection success!\");\n  console.log(\"Sequelize is ready to use!\");\n\n  const cat = await Cat.findByPk(1);\n  console.log(cat.toJSON());\n\n  await sequelize.close();\n}\n\nmain();\n\n// This code prints:\n//\n// Executing (default): SELECT \"id\", \"firstName\", \"specialSkill\", \"age\", \"createdAt\", \"updatedAt\" FROM \"Cats\" AS \"Cat\" WHERE \"Cat\".\"id\" = 1;\n// {\n//   id: 1,\n//   firstName: 'Markov',\n//   specialSkill: 'sleeping',\n//   age: 5,\n//   createdAt: 2020-02-03T21:32:28.960Z,\n//   updatedAt: 2020-02-03T21:32:28.960Z\n// }\n```\n\nWe use the `Cat.findByPk` static class method to fetch a single cat: the one\nwith `id` equal to 1. This static method exists because our `Cat` model class\n_extends_ `Sequelize.Model`.\n\n\"Pk\" stands for _primary key_; the `id` field is the primary key for the\n`Cats` table. `findByPk` returns a `Promise`, so we must `await` the\nresult. The result is an instance of the `Cat` model class.\n\nThe cleanest way to log a fetched database record is to first call the\n`toJSON` method. `toJSON` converts a `Cat` object to a _Plain Old\nJavaScript Object_ (POJO). `Cat` instances have many private variables\nand methods that can be distracting when printed. When you call\n`toJSON`, only the public data fields are copied into a JavaScript\n`Object`. Printing this raw JavaScript `Object` is thus much cleaner.\n\n> The author has a pet-peeve about the `.toJSON()` method of Sequelize,\n> it does not return JSON. It instead returns a POJO. If you needed it to be\n> JSON you would still need to call `JSON.stringify(cat.toJSON())`. Perhaps\n> they should have called it `.toObject` or `.toPOJO` instead.\n\nNote that Sequelize has logged the SQL query it ran to fetch Markov's\ninformation. This logging information is often helpful when trying to\nfigure out what Sequelize is doing.\n\nYou'll also notice that Sequelize puts double quotes around the table and field\nnames.  So if you are trying to look at your \"Cats\" table from the `psql`\ncommand you will need to quote them there as well. This is because PostgreSQL\nlowercases all identifiers like table and fields names before the query is run\nif they aren't quoted.\n\n## Reading And Changing Record Attributes\n\nWhile `toJSON` is useful for logging a `Cat` object, it is not the\nsimplest way to access individual column values. To read the `id`,\n`firstName`, etc of a `Cat`, you can directly access those attributes on\nthe `Cat` instance itself:\n\n```javascript\nasync function main() {\n  // Sequelize authentication code from above...\n\n  const cat = await Cat.findByPk(1);\n  console.log(`${cat.firstName} has been assigned id #${cat.id}.`);\n  console.log(`They are ${cat.age} years old.`)\n  console.log(`Their special skill is ${cat.specialSkill}.`);\n\n  await sequelize.close();\n}\n\nmain();\n\n// This code prints:\n//\n// Executing (default): SELECT \"id\", \"firstName\", \"specialSkill\", \"age\", \"createdAt\", \"updatedAt\" FROM \"Cats\" AS \"Cat\" WHERE \"Cat\".\"id\" = 1;\n// Markov has been assigned id #1.\n// They are 5 years old.\n// Their special skill is sleeping.\n```\n\nAccessing data directly through the `Cat` object is just like reading an\nattribute on any other JavaScript class. You may likewise _change_\nvalues in the database:\n\n```javascript\nasync function main() {\n  // Sequelize authentication code from above...\n\n  // Fetch existing cat from database.\n  const cat = await Cat.findByPk(1);\n  // Change cat's attributes.\n  cat.firstName = \"Curie\";\n  cat.specialSkill = \"jumping\";\n  cat.age = 123;\n\n  // Save the new name to the database.\n  await cat.save();\n\n  await sequelize.close();\n}\n\n// Prints:\n//\n// Executing (default): SELECT \"id\", \"firstName\", \"specialSkill\", \"age\", \"createdAt\", \"updatedAt\" FROM \"Cats\" AS \"Cat\" WHERE \"Cat\".\"id\" = 1;\n// Executing (default): UPDATE \"Cats\" SET \"firstName\"=$1,\"specialSkill\"=$2,\"age\"=$3,\"updatedAt\"=$4 WHERE \"id\" = $5\n\nmain();\n```\n\nNote that changing the `firstName` attribute value does not immediately\nchange the stored value in the SQL database. Changing the `firstName`\nwithout calling `save` **has no effect** on the database. Only when we\ncall `cat.save()` (and `await` the promise to resolve) will the changes\nto `firstName`, `specialSkill`, and `age` be saved to the SQL database.\nAll these values are updated simultaneously.\n\n## Conclusion\n\nHaving completed this reading, you should be able to:\n\n* Describe what an Object Relational Mapping is and what it is used for.\n* Install the `sequelize`, `sequelize-cli`, `pg` packages.\n* Configure Sequelize via the `config/config.json` file.\n* Use Sequelize's `authenticate` method to verify that Sequelize can\n  connect to the database.\n* Use the Sequelize CLI `model:generate` command to generate a model\n  file.\n* Configure a model file to tell Sequelize about each database column.\n* Use the `findByPk` class method to fetch data from a SQL table.\n* Read data attributes from a model instance.\n* Modify a model instance's attributes and save the changes back to the\n  SQL database using the `save` method.\n\n[undocumented]: https://codewithhugo.com/using-es6-classes-for-sequelize-4-models/\n"
  },
  "success": true
}