{
  "template": {
    "taskId": "d365bcc4-27c3-42c9-97da-624c83576bf8",
    "name": "Database Migrations",
    "repo": "Modular-Curriculum",
    "path": "content/relational-databases/topics/orm/readings/reading-02-what-are-database-migrations-orm-js.md",
    "type": "Reading",
    "timeEstimate": 1800,
    "urls": [
      "database-migrations"
    ],
    "topic": "Homework for Thursday",
    "subtopic": "Homework",
    "body": "# Using Database Migrations\n\nWe've seen how to use an ORM like Sequelize to fetch and store data in a\nSQL database using JavaScript classes and methods. Sequelize also lets\nyou write JavaScript code that creates, modifies, or drops SQL tables.\nThe JavaScript code that does this is called a _migration_. A migration\n\"moves\" the database from an old schema to a new schema.\n\nWhen you finish this reading you will be able to:\n\n* Describe advantages to using migrations over raw SQL commands to\n  create and drop tables.\n* Write migrations that create and drop tables.\n* Undo incorrect migrations, fix them, and rerun them.\n\n## Sequelize Migration Files\n\nIn the prior reading we assumed that a `Cats` table already existed in\nour `catsdb` database. In this reading, we will presume that the `Cats`\ntable does not exist, and that we have to create the table ourselves.\nThis is the typical case when you aren't merely interacting with a\npreexisting database. When you develop your own application, the\ndatabase will start out empty and with a blank schema.\n\nWe previously used the Sequelize CLI tool to autogenerate a `Cat` model\nfile like so:\n\n```bash\n# Oops, forgot age:integer!\nnpx sequelize model:generate --name Cat --attributes \"firstName:string,specialSkill:string\"\n```\n\nWe noted that this creates _two_ files. We've already examined the model\nfile `./models/cat.js`. We will now look at the auto-generated\n_migration_ file `./migrations/20200203211508-create-cat.js`.\n\n```javascript\n// ./migrations/20200203211508-create-cat.js\n\n'use strict';\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Cats', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      firstName: {\n        type: Sequelize.STRING\n      },\n      specialSkill: {\n        type: Sequelize.STRING\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.dropTable('Cats');\n  }\n};\n```\n\nThe migration file exports two functions: `up` and `down`. The `up`\nfunction tells Sequelize how to create a `Cats` table. The `down`\nfunction tells Sequelize how to \"undo\" the `up` function. The `down`\nfunction drops the `Cats` table.\n\nWe will examine these functions more closely, but let's first see how to\nuse a migration.\n\n>Note: The timestamp `20200203211508` preceding `-create-cat.js`\n>represents February 2, 2020. It gives the time and day that the\n>migration was generated. (Your date should be when you generated your migration)\n>By using the date and time as part of the filename, all migration files will\n>have unique names. Also, alphabetical sorting will order the files from oldest\n>to most recent migration.\n\n## Running A Migration\n\nTo create the `Cats` table, we must run our migration code. Having\ngenerated the `20200203211508-create-cat.js` migration file, we will use\nthe Sequelize CLI tool to run the migration. We may do this like so:\n\n```bash\n# Run the migration's `up` method.\nnpx sequelize db:migrate\n```\n\nBy giving Sequelize the `db:migrate` subcommand, it will know that we\nare asking it to run any new migrations. To run a migration, Sequelize\nwill call the `up` method defined in the migration file. The `up` method\nwill run the necessary `CREATE TABLE ...` SQL command for us. Sequelize\nwill record (in a special `catsdb` table called `SequelizeMeta`) that\nthe migration has been run. The next time we call `npx sequelize\ndb:migrate`, Sequelize will not try to \"redo\" this already performed\nmigration. It will do nothing the second time.\n\nHaving run the migration, we can verify that the `Cats` table looks like\nit should (with the exception of the `age` column):\n\nNote that we we are using the table name in quotes here in `psql`.\n\n```\ncatsdb=> \\d \"Cats\";\n                                         Table \"public.Cats\"\n    Column    |           Type           | Collation | Nullable\n--------------+--------------------------+-----------+----------\n id           | integer                  |           | not null\n firstName    | character varying(255)   |           |\n specialSkill | character varying(255)   |           |\n createdAt    | timestamp with time zone |           | not null\n updatedAt    | timestamp with time zone |           | not null\nIndexes:\n    \"Cats_pkey\" PRIMARY KEY, btree (id)\n```\n\n## Rolling Back A Migration\n\nWe made a mistake when generating our `Cat` migration. We forgot to\ninclude the `age` column.\n\nOne way to fix this is to generate a *second* migration that adds the\nforgotten `age` column. If we have already pushed our migration code to\na remote git server, we should opt for this option.\n\nIf the migration has not yet been pushed, we can fix the migration\ndirectly. We will \"undo\" (AKA _rollback_) the migration that created the\n`Cats` table (dropping the table), fix the `up` method so that the `age`\ncolumn is included, and finally rerun the migration.\n\n> Note: this is not the same as the SQL command ROLLBACK.\n\nTo undo the migration, we run:\n\n```bash\nnpx sequelize db:migrate:undo\n```\n\nSequelize will call the `down` method for us, and the `Cats` table is\ndropped.\n\nWhy should you not use the `db:migrate:undo` way when the migration file\nhas already been pushed to a remote git server? The reason is this: you\ncan easily tell other developers to fix a broken migration by writing a\nsecond fixup migration (for instance, that adds the `age` column). All\nyou need to do is check this new migration file into source control and\npush it. When another developer pulls your new migration code, the next\ntime they run `npx sequelize db:migrate`, your fixup migration will be\nrun on their local machine.\n\nWhen rolling back already-checked-in migrations, there is no way to\neasily communicate to other developers that they should (1) rollback\nyour migration and (2) rerun the newly corrected version of this\nmigration. To avoid this communication problem, you should only rollback\ncommits if you haven't already pushed them to a remote git server.\n\n## Editing A Migration File\n\nLet's examine the `up` and `down` methods more closely. Let's start with\nthe `up` method:\n\n```javascript\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Cats', {\n      id: {\n        allowNull: false,\n        autoIncrement: true,\n        primaryKey: true,\n        type: Sequelize.INTEGER\n      },\n      firstName: {\n        type: Sequelize.STRING\n      },\n      specialSkill: {\n        type: Sequelize.STRING\n      },\n      createdAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      },\n      updatedAt: {\n        allowNull: false,\n        type: Sequelize.DATE\n      }\n    });\n  },\n  // ...\n};\n```\n\nThe `up` method will be passed a QueryInterface\n([documentation][query-interface-docs]) object. This object provides a\nnumber of commands for modifying the SQL database schema. The\n`createTable` method is amongst the most important.\n\n[query-interface-docs]: https://sequelize.org/master/class/lib/query-interface.js~QueryInterface.html\n\nWe pass the table name (`'Cats'`) along with an object mapping column\nnames to column attributes. Every column must have a specified `type`.\nThis is similar to what we saw when we generated a model file. Note that\nwe **do not** take `id`, `createdAt`, or `updatedAt` for granted. We\nneed to include those columns. Luckily, everything has been\nauto-generated for us!\n\nWe will talk about `allowNull` and `primaryKey` in a later reading.\nThese attributes ask Sequelize to add database constraints to a column.\nLikewise we will ignore `autoIncrement` for the moment (this allows a\nunique `id` to be auto-generated by the database for each saved row in\nthe `Cats` table).\n\nWe fix the `up` method like so:\n\n```javascript\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    return queryInterface.createTable('Cats', {\n      // ...\n      firstName: {\n        type: Sequelize.STRING\n      },\n      specialSkill: {\n        type: Sequelize.STRING\n      },\n      // Here we add the `age` column.\n      age: {\n        type: Sequelize.INTEGER,\n      },\n      // ...\n    });\n  },\n  // ...\n};\n```\n\nAdding the `age` column to the migration is a lot like how we added\n`age` to our model file.\n\nHaving fixed our migration, we may now \"rerun\" it the same way we ran it\nthe first time:\n\n```bash\nnpx sequelize db:migrate\n```\n\nWe may now behold the fixed table:\n\n```\ncatsdb=> \\d \"Cats\"\n                                         Table \"public.Cats\"\n    Column    |           Type           | Collation | Nullable\n--------------+--------------------------+-----------+----------\n id           | integer                  |           | not null\n firstName    | character varying(255)   |           |\n specialSkill | character varying(255)   |           |\n age          | integer                  |           |\n createdAt    | timestamp with time zone |           | not null\n updatedAt    | timestamp with time zone |           | not null\nIndexes:\n    \"Cats_pkey\" PRIMARY KEY, btree (id)\n```\n\n## `up` And `down` are Asynchronous\n\nA final note about `up` (and also `down`). Sequelize expects `up` to be\n*asynchronous*. That is, Sequelize expects `up` to return a `Promise`\nobject. Sequelize will wait for the `Promise` to be resolved. When the\n`Promise` is resolved, Sequelize will know the work of the `up` method\nis complete.\n\nThe `createTable` method is also asynchronous (returns a `Promise`). The\npromise resolves when `createTable` is done creating the table. This is\nwhy `up` is written as:\n\n```javascript\nmodule.exports = {\n  up: (queryInterface, Sequelize) => {\n    // up returns Promise returned by `createTable`.\n    return queryInterface.createTable('Cats', {\n      // ...\n    });\n  },\n  // ...\n};\n```\n\nSequelize is able to autogenerate a migration to create a `Cats` table,\nbut many other migrations (for instance, to add an `age` column to our\n`Cats` table) must be written by hand. When writing your own migrations,\nyou may prefer using `async`/`await`, which is clearer:\n\n```javascript\nmodule.exports = {\n  // Note the addition of the `async` keyword\n  up: async (queryInterface, Sequelize) => {\n    // await `createTable` to finish its work.\n    await queryInterface.createTable('Cats', {\n      // ...\n    });\n\n    // No need to return anything. An `async` method always returns a\n    // Promise that waits for all `await`ed work to be performed.\n  },\n  // ...\n};\n```\n\n## Writing A `down` Method\n\nA `down` method is written just like an `up` method. In the `down`\nmethod we \"undo\" what has been performed by the `up` method. We call\n`QueryInterface`'s `dropTable` method to drop the `Cats` table we\ncreated in `up`:\n\n```javascript\nmodule.exports = {\n  // ...\n  down: (queryInterface, Sequelize) => {\n    return queryInterface.dropTable('Cats');\n  }\n};\n\n// OR, async/await way:\nmodule.exports = {\n  // ...\n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.dropTable('Cats');\n  }\n};\n```\n\n**Imagine we had forgotten to drop the `Cats` table in the `down`\nmethod.** That is: imagine the `down` method was somehow left empty. If\nwe rollback the migration nothing will be done by the empty `down`\nmethod. Thus the incorrect `Cats` table we created will not have been\ndropped. The wrong `Cats` table would still exist.\n\nImagine we next fix the migration's `up` method. We want to rerun the\nmigration now and create the corrected `Cats` table. But when try to do\nthis, Sequelize will hit an error! Rerunning the migration will try to\n`CREATE TABLE \"Cats\"` again, but SQL will complain because a `Cats`\ntable already exists. It was created the first time we ran the\nmigration, but never dropped when we tried to rollback the migration!\n\nInevitably all programmers will sometimes make mistakes like this. In\nthese circumstances, you will probably have to open `psql` and write a\nSQL `DROP TABLE` command to fix things. Having manually corrected\nthings, you can finally rerun the corrected migration.\n\nYou should **never** manually drop a table on a production database.\nThat is incredibly dangerous, and typically cannot be undone. Even if\ndatabase backups do not exist, recently inserted data will be lost\nforever. This is yet another reason why you ought not rollback\nmigrations that have been pushed from your local development\nenvironment!\n\n## Advantages Of Migrations\n\nHaving seen how to _use_ Sequelize migrations, we can discuss their\nbenefits versus writing SQL commands like `CREATE TABLE ...` yourself.\n\nThe first advantage is that Sequelize migration code is written in\nJavaScript, which you may find simpler to write/read than the\ncorresponding SQL code. Most programmers write more JavaScript than SQL,\nso they are typically better at remembering how to do things in\nJavaScript than in SQL.\n\nA second advantage is that migration files store SQL schema change code\npermanently. The migration files can be checked into git, so that you\ndon't ever forget how your database was configured.\n\nA third (related) advantage comes when another developer wants to\ncollaborate on your JavaScript program. By cloning your git repository,\nthey get all the migration files, too. To setup their own copy of your\ndatabase, a collaborator can run the migration files on their own\ncomputer, playing back the schema changes one-by-one. Because they apply\nthe same migrations as you, they end up with the same schema as you.\n\nLast, by using migrations you are able to rollback database changes to\nfix bugs. This can be helpful in a local development environment where\nit is typical to make mistakes. Remember though: you should **never**\nrollback migrations that have been run on a production server.\n\n## Conclusion\n\nHaving completed this reading, you now are able to:\n\n* Describe advantages to using migrations over raw SQL commands to\n  create, modify, and drop tables.\n* Generate (and modify as needed)) migrations that create and drop\n  tables.\n* Run migrations to change the database schema.\n* Undo incorrect migrations, fix them, and rerun them.\n"
  },
  "success": true
}