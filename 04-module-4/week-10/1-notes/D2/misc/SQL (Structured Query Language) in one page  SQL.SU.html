<h1 id="sql-structured-query-language-in-one-page">SQL (Structured Query Language) in one page</h1>
<table>
<caption>
Data Types
</caption>
<tbody>
<tr>
<th>
Data Type
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
integer(size)
</td>
<td rowspan="4">
    Hold integers only. The maximum number of digits are specified in parenthesis.
</td>
</tr>
<tr>
<td>
int(size)
</td>
</tr>
<tr>
<td>
smallint(size)
</td>
</tr>
<tr>
<td>
tinyint(size)
</td>
</tr>
<tr>
<td>
decimal(size,d)
</td>
<td rowspan="2">
    Hold numbers with fractions. The maximum number of digits are specified in “size”. The maximum number of digits to the right of the decimal is specified in “d”.
</td>
</tr>
<tr>
<td>
numeric(size,d)
</td>
</tr>
<tr>
<td>
char(size)
</td>
<td>
    Holds a fixed length string (can contain letters, numbers, and special characters). The fixed size is specified in parenthesis.
</td>
</tr>
<tr>
<td>
varchar(size)
</td>
<td>
    Holds a variable length string (can contain letters, numbers, and special characters). The maximum size is specified in parenthesis.
</td>
</tr>
<tr>
<td>
date(yyyymmdd)
</td>
<td>
    Holds a date
</td>
</tr>
</tbody>
</table>
<p>ALTER TABLE table_name ADD column_name datatype       Add columns in an existing table. ALTER TABLE Person ADD Sex char(6) ALTER TABLE table_name DROP column_name datatype       Delete columns in an existing table. ALTER TABLE Person DROP Sex char(6) DROP TABLE table_name       Delete a table. DROP TABLE Person Index Manipulation CREATE INDEX index_name<br />
ON table_name (column_name_1, column_name_2, …)       Create a simple index. CREATE INDEX PersonIndex<br />
ON Person (LastName, FirstName) CREATE UNIQUE INDEX index_name<br />
ON table_name (column_name_1, column_name_2, …)       Create a unique index. CREATE UNIQUE INDEX PersonIndex<br />
ON Person (LastName DESC) DROP INDEX table_name.index_name       Delete a index. DROP INDEX Person.PersonIndex Data Manipulation INSERT INTO table_name<br />
VALUES (value_1, value_2,….)       Insert new rows into a table. INSERT INTO Persons<br />
VALUES(‘Hussein’, ‘Saddam’, ‘White House’) INSERT INTO table_name (column1, column2,…)<br />
VALUES (value_1, value_2,….) INSERT INTO Persons (LastName, FirstName, Address)<br />
VALUES(‘Hussein’, ‘Saddam’, ‘White House’) UPDATE table_name<br />
SET column_name_1 = new_value_1, column_name_2 = new_value_2<br />
WHERE column_name = some_value       Update one or several columns in rows. UPDATE Person<br />
SET Address = ‘ups’<br />
WHERE LastName = ‘Hussein’ DELETE FROM table_name<br />
WHERE column_name = some_value       Delete rows in a table. DELETE FROM Person WHERE LastName = ‘Hussein’ TRUNCATE TABLE table_name       Deletes the data inside the table. TRUNCATE TABLE Person Select SELECT column_name(s) FROM table_name       Select data from a table. SELECT LastName, FirstName FROM Persons SELECT * FROM table_name       Select all data from a table. SELECT * FROM Persons SELECT DISTINCT column_name(s) FROM table_name       Select only distinct (different) data from a table. SELECT DISTINCT LastName, FirstName FROM Persons SELECT column_name(s) FROM table_name<br />
WHERE column operator value<br />
      AND column operator value<br />
      OR column operator value<br />
      AND (… OR …)<br />
      …       Select only certain data from a table. SELECT * FROM Persons WHERE sex=‘female’</p>
<table>
<caption>
Operators
</caption>
<tbody>
<tr>
<th>
Operator
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
=
</td>
<td>
    Equal
</td>
</tr>
<tr>
<td>
&lt;&gt;
</td>
<td>
    Not equal
</td>
</tr>
<tr>
<td>
&gt;
</td>
<td>
    Greater than
</td>
</tr>
<tr>
<td>
&lt;
</td>
<td>
    Less than
</td>
</tr>
<tr>
<td>
&gt;=
</td>
<td>
    Greater than or equal
</td>
</tr>
<tr>
<td>
&lt;=
</td>
<td>
    Less than or equal
</td>
</tr>
<tr>
<td>
BETWEEN
</td>
<td>
    Between an inclusive range
</td>
</tr>
<tr>
<td>
LIKE
</td>
<td>
    Search for a pattern.<br>A “%” sign can be used to define wildcards (missing letters in the pattern) both before and after the pattern.
</td>
</tr>
</tbody>
</table>
<p>SELECT * FROM Persons WHERE Year&gt;1970 SELECT * FROM Persons<br />
WHERE FirstName=‘Saddam’<br />
AND LastName=‘Hussein’ SELECT * FROM Persons<br />
WHERE FirstName=‘Saddam’<br />
OR LastName=‘Hussein’ SELECT * FROM Persons WHERE<br />
(FirstName=‘Tove’ OR FirstName=‘Stephen’)<br />
AND LastName=‘Svendson’ SELECT * FROM Persons WHERE FirstName LIKE ‘O%’ SELECT * FROM Persons WHERE FirstName LIKE ‘%a’ SELECT * FROM Persons WHERE FirstName LIKE ‘%la%’ SELECT column_name(s) FROM table_name<br />
WHERE column_name IN (value1, value2, …)       The IN operator may be used if you know the exact value you want to return for at least one of the columns. SELECT * FROM Persons<br />
WHERE LastName IN (‘Hansen’,‘Pettersen’) SELECT column_name(s) FROM table_name<br />
ORDER BY row_1, row_2 DESC, row_3 ASC, …       Select data from a table with sort the rows.</p>
<p>Note:</p>
<ul>
<li>ASC (ascend) is a alphabetical and numerical order (optional)</li>
<li>DESC (descend) is a reverse alphabetical and numerical order</li>
</ul>
<p>SELECT * FROM Persons<br />
ORDER BY LastName SELECT FirstName, LastName FROM Persons<br />
ORDER BY LastName DESC SELECT Company, OrderNumber FROM Orders<br />
ORDER BY Company DESC, OrderNumber ASC SELECT column_1, …, SUM(group_column_name)<br />
FROM table_name<br />
GROUP BY group_column_name       GROUP BY… was added to SQL because aggregate functions (like SUM) return the aggregate of all column values every time they are called, and without the GROUP BY function it was impossible to find the sum for each individual group of column values. SELECT Company, SUM(Amount)<br />
FROM Sales<br />
GROUP BY Company</p>
<table>
<caption>
Some aggregate functions
</caption>
<tbody>
<tr>
<th>
Function
</th>
<th>
Description
</th>
</tr>
<tr>
<td>
AVG(column)
</td>
<td>
    Returns the average value of a column
</td>
</tr>
<tr>
<td>
COUNT(column)
</td>
<td>
    Returns the number of rows (without a NULL value) of a column
</td>
</tr>
<tr>
<td>
MAX(column)
</td>
<td>
    Returns the highest value of a column
</td>
</tr>
<tr>
<td>
MIN(column)
</td>
<td>
    Returns the lowest value of a column
</td>
</tr>
<tr>
<td>
SUM(column)
</td>
<td>
    Returns the total sum of a column
</td>
</tr>
</tbody>
</table>
<p>SELECT column_1, …, SUM(group_column_name)<br />
FROM table_name<br />
GROUP BY group_column_name<br />
HAVING SUM(group_column_name) condition value       HAVING… was added to SQL because the WHERE keyword could not be used against aggregate functions (like SUM), and without HAVING… it would be impossible to test for result conditions. SELECT Company, SUM(Amount)<br />
FROM Sales<br />
GROUP BY Company<br />
HAVING SUM(Amount)&gt;10000 Alias SELECT column_name AS column_alias FROM table_name Column name alias SELECT LastName AS Family, FirstName AS Name<br />
FROM Persons SELECT table_alias.column_name FROM table_name AS table_alias Table name alias SELECT LastName, FirstName<br />
FROM Persons AS Employees Join SELECT column_1_name, column_2_name, …<br />
FROM first_table_name<br />
INNER JOIN second_table_name<br />
ON first_table_name.keyfield = second_table_name.foreign_keyfield        The INNER JOIN returns all rows from both tables where there is a match. If there are rows in first table that do not have matches in second table, those rows will not be listed. SELECT Employees.Name, Orders.Product<br />
FROM Employees<br />
INNER JOIN Orders<br />
ON Employees.Employee_ID=Orders.Employee_ID SELECT column_1_name, column_2_name, …<br />
FROM first_table_name<br />
LEFT JOIN second_table_name<br />
ON first_table_name.keyfield = second_table_name.foreign_keyfield        The LEFT JOIN returns all the rows from the first table, even if there are no matches in the second table. If there are rows in first table that do not have matches in second table, those rows also will be listed. SELECT Employees.Name, Orders.Product<br />
FROM Employees<br />
LEFT JOIN Orders<br />
ON Employees.Employee_ID=Orders.Employee_ID SELECT column_1_name, column_2_name, …<br />
FROM first_table_name<br />
RIGHT JOIN second_table_name<br />
ON first_table_name.keyfield = second_table_name.foreign_keyfield        The RIGHT JOIN returns all the rows from the second table, even if there are no matches in the first table. If there had been any rows in second table that did not have matches in first table, those rows also would have been listed. SELECT Employees.Name, Orders.Product<br />
FROM Employees<br />
RIGHT JOIN Orders<br />
ON Employees.Employee_ID=Orders.Employee_ID UNION SQL_Statement_1<br />
UNION<br />
SQL_Statement_2       Select all different values from SQL_Statement_1 and SQL_Statement_2 SELECT E_Name FROM Employees_Norway<br />
UNION<br />
SELECT E_Name FROM Employees_USA SQL_Statement_1<br />
UNION ALL<br />
SQL_Statement_2       Select all values from SQL_Statement_1 and SQL_Statement_2 SELECT E_Name FROM Employees_Norway<br />
UNION<br />
SELECT E_Name FROM Employees_USA SELECT INTO/IN SELECT column_name(s)<br />
INTO new_table_name<br />
FROM source_table_name<br />
WHERE query       Select data from table(S) and insert it into another table. SELECT * INTO Persons_backup FROM Persons SELECT column_name(s)<br />
IN external_database_name<br />
FROM source_table_name<br />
WHERE query       Select data from table(S) and insert it in another database. SELECT Persons.* INTO Persons IN ‘Backup.db’ FROM Persons WHERE City=‘Sandnes’ CREATE VIEW CREATE VIEW view_name AS<br />
SELECT column_name(s)<br />
FROM table_name<br />
WHERE condition       Create a virtual table based on the result-set of a SELECT statement. CREATE VIEW [Current Product List] AS<br />
SELECT ProductID, ProductName<br />
FROM Products<br />
WHERE Discontinued=No OTHER</p>
<p><a href="http://www.cheat-sheets.org/sites/sql.su/">Source</a></p>
